<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MathDefend</title>
  <style>
       /* Basic Reset & Body Layout */
    body {
        margin: 0;
        overflow: hidden; /* Prevent scrollbars on body */
        font-family: sans-serif;
        display: flex; /* Use Flexbox for layout */
        height: 100vh; /* Full viewport height */
        background-color: #f0f0f0; /* Background for area outside canvas */
    }

    /* Sidebar Styling */
    #sidebar {
        width: 280px; /* Width of the sidebar */
        padding: 15px;
        background-color: #e8e8e8;
        border-right: 2px solid #ccc;
        display: flex;
        flex-direction: column; /* Stack elements vertically */
        height: 100vh; /* Full height */
        box-sizing: border-box; /* Include padding in width/height */
        overflow-y: auto; /* Add scroll if content overflows */
    }

    /* Info Panel Styling */
    #infoPanel {
        border-bottom: 1px solid #ccc;
        padding-bottom: 15px;
        margin-bottom: 15px;
        text-align: center;
    }
    #waveStatus {
        margin-bottom: 10px;
        font-size: 18px;
        font-weight: bold;
        color: #333;
    }
    #scoreDisplay, #unitCountDisplay {
        font-size: 16px;
        margin-bottom: 5px;
    }

    /* Solving Panel Styling */
    #mathProblem {
        border-bottom: 1px solid #ccc;
        padding-bottom: 20px;
        margin-bottom: 20px;
        text-align: center;
    }
    #mathForm span:first-child { /* Target the "X op Y = ?" part */
        display: block; /* Make it take its own line */
        font-size: 24px; /* Larger math problem */
        font-weight: bold;
        margin-bottom: 10px;
    }
     #mathForm span + span { /* Target the Bonus span */
        font-size: 16px; /* Keep bonus text normal size */
        margin-left: 5px !important;
     }
      #answerInput {
        display: block;       /* Keep as block */
        width: 90%;           /* INCREASED: Make it wider (adjust % as needed) */
        margin: 15px auto;    /* Keeps vertical margin & centers horizontally */
        padding: 12px;        /* Adjust padding if needed */
        font-size: 24px;      /* INCREASED: Slightly larger font */
        text-align: center;   /* Keep text centered */
        box-sizing: border-box;

        /* --- START NEW STYLES --- */
        border: none;                           /* Remove the default border */
        border-bottom: 2px solid #aaa;       /* Add a subtle bottom border instead */
        outline: none;                          /* Remove the focus outline */
        background-color: #fdfdfd;           /* Slightly off-white background */
        border-radius: 0;                       /* Remove rounding for a flatter look */

        /* Hide spinner arrows for Webkit browsers (Chrome, Safari, Edge) */
        -webkit-appearance: none;
        margin: 15px auto; /* Re-declare margin just in case */ /* Re-added margin: auto for centering */

        /* Hide spinner arrows for Firefox */
        -moz-appearance: textfield;
        /* --- END NEW STYLES --- */
    }

    /* Optional: Style on focus */
    #answerInput:focus {
        border-bottom-color: #3498db; /* Change bottom border color on focus */
    }

    /* Hide spinner arrows specifically (more robust for Webkit) */
    #answerInput::-webkit-outer-spin-button,
    #answerInput::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    #mathForm button[type="submit"] { /* Style the submit button */
        padding: 8px 25px;
        font-size: 16px;
        cursor: pointer;
        margin-top: 5px;
    }


    /* Controls Panel Styling */
    #controls {
        display: flex;
        flex-direction: column; /* Stack buttons vertically */
        gap: 10px; /* Space between buttons */
    }
    #controls button {
        padding: 12px 5px; /* More padding vertically */
        font-size: 14px;
        cursor: pointer;
        border: 1px solid #aaa;
        background-color: #f9f9f9;
        border-radius: 4px;
        text-align: center;
    }
     #controls button:hover {
         background-color: #eee;
     }
     #upgradeCapButton { /* Keep gold style */
         background-color: gold !important;
         font-weight: bold;
     }
     #upgradeCapButton:hover {
         background-color: #e6c300 !important;
     }

         #correctAnswerOverlay {
      display: none; /* Start hidden */
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.75); /* Slightly less dark than game over? */
      color: white;
      z-index: 9; /* Below Game Over (10), above everything else */

      /* Flexbox for centering the message */
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }

    #correctAnswerMessage {
        background-color: rgba(200, 50, 50, 0.8); /* Reddish background */
        padding: 30px 40px;
        border-radius: 10px;
        font-size: 28px; /* Large font */
        font-weight: bold;
        border: 2px solid #fff;
        max-width: 80%;
    }
	  
    /* Canvas Styling */
    canvas#gameCanvas {
        display: block; /* Remove extra space below */
        background: #f0f0f0;
        /* Flex grow takes remaining space, but width/height attributes take precedence */
        /* We control size via attributes mainly */
        /* Remove auto margins if they existed */
        /* Add border if desired */
        border-left: 2px solid #ccc; /* Optional: border between sidebar and canvas */
    }

    /* Game Over Screen Styling */
    #gameOverScreen {
      display: none; /* Start hidden */
      /* Flex properties for centering (keep from previous fix) */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      /* Full screen overlay (keep from previous fix) */
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.85);
      color: white;
      font-size: 24px;
      text-align: center;
      padding: 20px;
      z-index: 10;
      box-sizing: border-box;
      overflow-y: auto;
    }
    /* Styles for children of gameOverScreen (keep from previous fix) */
    #gameOverScreen h2 { margin-top: 0; margin-bottom: 15px; font-size: 36px; }
    #gameOverScreen p { margin: 10px 0; }
    #highScoreListContainer { max-width: 400px; width: 90%; margin-top: 20px; text-align: left; border: 1px solid #555; padding: 15px; background-color: rgba(20, 20, 20, 0.5); border-radius: 5px; }
    #highScoreListContainer h3 { margin-top: 0; text-align: center; }
    #highScoreListContainer ol { padding-left: 25px; margin-bottom: 0; }
    #highScoreListContainer li { margin-bottom: 5px; }
  </style>
   <!-- Firebase v9+ Modular SDK -->
    <!-- Core App Module (You already have this) -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js"; // Use your actual version if different

      // Paste your actual firebaseConfig object here!
const firebaseConfig = {
    apiKey: "AIzaSyCx_SQ23AvzsOj1btO9YqzLQQ-C9xD07_E",
    authDomain: "math-game-leaderboard-e6970.firebaseapp.com",
    projectId: "math-game-leaderboard-e6970",
    storageBucket: "math-game-leaderboard-e6970.firebasestorage.app",
    messagingSenderId: "291357117755",
    appId: "1:291357117755:web:e1f49d75b614ff3b227b1e"
  };

  // Initialize Firebase
      const app = initializeApp(firebaseConfig);

      // Make the initialized app available globally or pass it down
      // For simplicity here, we can make it accessible via a global scope if needed,
      // but ideally you'd import necessary functions directly in your main script.
      // Let's make it accessible for now:
      window.firebaseApp = app;
       </script>

    <!-- Firestore Module -->
    <script type="module" src="https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js"></script>
	    
</head>
 <!-- START SIDEBAR -->
    <div id="sidebar">

        <!-- Info Section -->
        <div id="infoPanel">
            <div id="waveStatus">Game Starting...</div>
            <div id="scoreDisplay">
                ðŸª™ Gold: <span id="score">0</span>   
                ðŸ“ˆ Score: <span id="mathScore">0</span>
            </div>
            <div id="armyCountDisplay">Units: 0 / ?</div>
        </div>

        <!-- Solving Section -->
        <div id="mathProblem"> <!-- Renamed from mathProblem for clarity -->
             <form id="mathForm">
                 <!-- Content generated by JS -->
            </form>
        </div>

        <!-- Buttons Section -->
        <div id="controls">
            <button onclick="spawnUnit('melee')">Spawn [M]elee (Cost: 10)</button>
            <button onclick="spawnUnit('archer')">Spawn [A]rcher (Cost: 15)</button>
            <button onclick="spawnUnit('mage')">Spawn Ma[G]e (Cost: 30)</button>
            <button id="spawnChampionBtn" onclick="spawnChampion()">Spawn [C]hampion (Cost: 200)</button> <!-- Initial text -->
            <button id="upgradeCapButton" onclick="upgradeArmyCap()" style="background-color: gold;">
                [U]pgrade Cap (<span id="capBefore">10</span> -> <span id="capAfter">15</span>) (Cost: <span id="capCost">75</span>)
            </button>
        </div>

    </div>
    <!-- END SIDEBAR -->

    <!-- GAME CANVAS -->
    <canvas id="gameCanvas" width="800" height="500"></canvas> <!-- Adjust width/height if needed -->

      <div id="correctAnswerOverlay">
        <div id="correctAnswerMessage">
            <!-- Content will be set by JavaScript -->
        </div>
    </div>
	
    <!-- GAME OVER SCREEN (remains outside sidebar) -->
    <div id="gameOverScreen">Game Over!<br/><span>Final Score: 0</span></div>

  <script type="module">	
     // --- START FIREBASE V9+ SETUP ---
    // Access the initialized app from the global scope (or import if using modules for game script too)
    const app = window.firebaseApp; // Get the app initialized in the head

   // Import necessary Firestore functions DIRECTLY from the SDK URL
        import {
            getFirestore,
            collection,
            getDocs,
            query,
            orderBy,
            limit,
            addDoc,
            serverTimestamp // Make sure you import serverTimestamp specifically
        } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js"; // Use your actual version


    // Get a Firestore instance
    const db = getFirestore(app); // Pass the initialized app
    const highScoresCollectionRef = collection(db, 'highscores'); // Reference to the collection
    const MAX_HIGH_SCORES = 10;
    // --- END FIREBASE V9+ SETUP ---

    // --- Champion Constants ---
const CHAMPION_RADIUS = 15;
const CHAMPION_COLOR = '#FFD700'; // Gold
const CHAMPION_MAX_HP = 600;
const CHAMPION_SPEED = 1.0; // Slowest
const CHAMPION_ATTACK_DAMAGE = 10;
const CHAMPION_ATTACK_COOLDOWN = 55; // Frames
const CHAMPION_ATTACK_RANGE = 35;

const CHAMPION_RALLY_COOLDOWN = 1200; // Frames (20 seconds)
const CHAMPION_RALLY_DURATION = 500; // Frames (5 seconds)
const CHAMPION_RALLY_RANGE = 200;
const CHAMPION_RALLY_BUFF_PERCENT = 0.50; // +30% damage

const CHAMPION_SLAM_COOLDOWN = 1000; // Frames (25 seconds)
const CHAMPION_SLAM_TRIGGER_RANGE = 100; // Enemy must be this close to trigger
const CHAMPION_SLAM_EFFECT_RANGE = 400; // Affects enemies within this range
const CHAMPION_SLAM_INITIAL_SPEED = 7.0; // Push speed
const CHAMPION_SLAM_DAMAGE = 50;

const CHAMPION_INITIAL_COST = 30;
const CHAMPION_COST_INCREASE = 200;
	  
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const SAFE_MARGIN = 40; // Keep units away from edges initially
    const SEPARATION_DISTANCE = 25; // Min distance units try to maintain
    const SEPARATION_STRENGTH = 0.5; // How strongly they push apart
    const FLASH_DURATION = 10; // Duration of damage flash effect in frames
    const WAVE_CLEAR_BASE_GOLD = 25;    // Base gold reward for clearing a wave
    const WAVE_CLEAR_GOLD_PER_WAVE = 5; // Additional gold per wave number
    
    const BASE_ARMY_CAP = 10;                  // Starting maximum number of player units
    const ARMY_CAP_INCREASE_PER_UPGRADE = 5;   // How many slots each upgrade adds
    const BASE_ARMY_CAP_UPGRADE_COST = 75;     // Cost of the *first* upgrade
    const ARMY_CAP_UPGRADE_COST_SCALING = 1.5; // Cost multiplier for subsequent upgrades (e.g., 1.8x)

    let currentArmyCap = BASE_ARMY_CAP;         // Player's current cap
    let armyCapUpgradeLevel = 0;                // How many times the cap has been upgraded

    const units = [];
    const enemies = [];
    const projectiles = [];
    let score = 100; // Starting gold
    let mathScore = 0;
    let currentAnswer = 0;
    let currentOperands = [0, 0];
    let currentOperator = '+';
    let gameRunning = true; // Flag to stop updates when game over
    let currentWave = 0;
    let waveState = 'INTERMISSION'; // Possible states: 'INTERMISSION', 'SPAWNING'
    let waveTimer = 0; // General timer for current phase (frames)
    let spawnTimer = 0; // Timer between spawns within a wave (frames)

    let enemiesToSpawnThisWave = 0;
    let enemiesSpawnedThisWave = 0;
    let waveSpawnInterval = 0; // Frames between spawns for the current wave

    let correctAnswerTimeoutId = null; // Timer ID for the answer overlay

    // Near other globals like 'score', 'units', 'enemies'
let currentChampionCost = CHAMPION_INITIAL_COST;
let championExists = false;

    const BASE_INTERMISSION_DURATION = 25 * 60; // 15 seconds in frames (assuming 60fps)
    const INITIAL_INTERMISSION_DURATION = 8 * 60; // Shorter pause before Wave 1
    const BASE_ENEMY_COUNT = 5;
    const ENEMY_COUNT_INCREASE_PER_WAVE = 2;
    const BASE_SPAWN_INTERVAL = 300; // Frames (2 seconds)
    const SPAWN_INTERVAL_DECREASE_PER_WAVE = 10; // Frames
    const MIN_SPAWN_INTERVAL = 35; // Minimum frames (0.5 seconds)
    const sndSpawnSuccess = new Audio('sounds/cash.mp3');
    const sndNoGold = new Audio('sounds/no-money.mp3');
    const sndEnemySpawn = new Audio('sounds/attack.mp3');
    const sndArcherFire = new Audio('sounds/shoot.mp3');
    const sndMeleeHit = new Audio('sounds/sword.mp3');
    const sndArrowHit = new Audio('sounds/shoot-hit.mp3');
    const sndMageBounce = new Audio('sounds/push.mp3');
    const sndHealPulse = new Audio('sounds/heal.mp3'); // Keep this one short!
    const sndMathCorrect = new Audio('sounds/correct-answer-sound.mp3');
    const sndMathIncorrect = new Audio('sounds/wrong-answer-sound.mp3');
    const sndWaveStart = new Audio('sounds/start-game.mp3');
    const sndGameOver = new Audio('sounds/game-over.mp3');
     const sndRallyCry = new Audio('sounds/rally_cry.mp3'); // Sound for rally activation
    const sndSlam = new Audio('sounds/slam_impact.mp3');   // Sound for slam activation
    // Optional: Adjust volume (0.0 to 1.0) if needed
    sndSpawnSuccess.volume = 1;
    sndNoGold.volume = 1;
    sndEnemySpawn.volume = 1;
    sndArcherFire.volume = 0.3;
    sndMeleeHit.volume = 0.5;
    sndArrowHit.volume = 0.3;
    sndMageBounce.volume = 0.7;
    sndHealPulse.volume = 0.7;
    sndMathCorrect.volume = 1;
    sndMathIncorrect.volume = 1;
    sndWaveStart.volume = 1;
    sndGameOver.volume = 1;
    const castle = {
      x: canvas.width / 2,
      y: canvas.height - 60, // Center Y of the castle structure base
      width: 120,
      height: 100,
      maxHp: 30000,
      hp: 30000
    };

	    // --- START ADDITION: Army Count Display Function ---
    function updateArmyCountDisplay() {
        const displayElement = document.getElementById('armyCountDisplay');
        if (displayElement) {
            displayElement.innerText = `Units: ${units.length} / ${currentArmyCap}`;

            // Optional: Change color if at cap
            if (units.length >= currentArmyCap) {
                displayElement.style.color = 'darkred'; // Indicate cap reached
                displayElement.style.fontWeight = 'bold';
            } else {
                displayElement.style.color = '#555'; // Default color
                displayElement.style.fontWeight = 'normal';
            }
        }
    }
    // --- END ADDITION ---


   function playSound(sound) {
        // Check if sound object is valid
        if (sound && typeof sound.play === 'function') {
            // Reset playback to the start - allows rapid re-triggering
            sound.currentTime = 0;
            sound.play().catch(error => {
                // Autoplay restrictions might prevent sound initially
                // Often resolves after first user interaction (click/key)
                // console.warn("Sound playback failed:", error);
            });
        } else {
            console.warn("Attempted to play invalid sound object:", sound);
        }
    }
	  
   function updateScoreDisplay() {
     document.getElementById('score').innerText = score;
     document.getElementById('mathScore').innerText = mathScore;
     updateChampionButtonDisplay(); // Add this call
   }


    function drawCastle() {
      const { x, y, width, height, hp, maxHp } = castle;
      const left = x - width / 2;
      const top = y - height / 2;

      // Draw structure
      ctx.fillStyle = '#5a4d41'; // Brownish color
      ctx.fillRect(left, top, width, height); // Main block

      ctx.fillStyle = '#8b7e75'; // Lighter stone color for details
      // Draw towers (simplified)
      const towerWidth = width * 0.2;
      const towerHeight = height * 1.2;
      ctx.fillRect(left - towerWidth * 0.1, top - (towerHeight-height), towerWidth, towerHeight); // Left tower
      ctx.fillRect(left + width - towerWidth*0.9, top - (towerHeight-height), towerWidth, towerHeight); // Right tower

      // Draw battlements (simplified crenellations)
      const battlementHeight = 15;
      const battlementWidth = 15;
      const numBattlements = Math.floor(width / (battlementWidth * 1.5));
      ctx.fillStyle = '#5a4d41';
      for(let i=0; i < numBattlements; i++) {
          ctx.fillRect(left + i * (battlementWidth * 1.5) + battlementWidth*0.25, top - battlementHeight, battlementWidth, battlementHeight);
      }

      // Health bar (above castle)
      const healthRatio = Math.max(0, hp / maxHp); // Ensure ratio doesn't go below 0
      const barWidth = 100;
      const barHeight = 10;
      const barX = x - barWidth / 2;
      const barY = top - 30; // Position the health bar above the castle

      ctx.save();
      ctx.fillStyle = '#333'; // Background of bar
      ctx.fillRect(barX, barY, barWidth, barHeight);
      ctx.fillStyle = healthRatio > 0.5 ? 'lime' : healthRatio > 0.2 ? 'yellow' : 'red'; // Color changes with health
      ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
      ctx.strokeStyle = '#222'; // Border for clarity
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      ctx.restore();
    }

// --- Champion Spawning Function ---
function spawnChampion() {
    if (!gameRunning) return;
    // console.log(`Attempting to spawn Champion. Exists: ${championExists}, Score: ${score}, Cost: ${currentChampionCost}`);

    if (championExists) {
        // console.log("Champion already exists!");
        playSound(sndNoMana); // Using no mana sound for "limit reached"
        return;
    }

    if (score < currentChampionCost) {
        // console.log("Not enough gold for Champion!");
        playSound(sndNoGold);
        return;
    }

    // Deduct cost & update state
    score -= currentChampionCost;
    championExists = true;

    // Spawn near castle
    const spawnZoneY = castle.y - castle.height / 2 - 60;
    let spawnX = castle.x + (Math.random() - 0.5) * castle.width * 1.0; // Closer to center
    let spawnY = spawnZoneY + (Math.random() - 0.5) * 30;
    spawnX = Math.max(SAFE_MARGIN, Math.min(spawnX, canvas.width - SAFE_MARGIN));
    spawnY = Math.max(SAFE_MARGIN, Math.min(spawnY, canvas.height - SAFE_MARGIN - castle.height));

    // Create and add Champion
    const champ = new Champion(spawnX, spawnY);
    units.push(champ);
    console.log("Champion Spawned!");

    // Increase cost for the *next* spawn
    currentChampionCost += CHAMPION_COST_INCREASE;

    // Update displays
    updateScoreDisplay(); // This should implicitly call updateChampionButtonDisplay
    playSound(sndSpawnSuccess); // Use generic spawn or create sndChampionSpawn
}
window.spawnChampion = spawnChampion; // Make it global
// --- Champion Button Update Function ---
function updateChampionButtonDisplay() {
    // *** MAKE SURE 'spawnChampionBtn' is the actual ID you use in your HTML ***
    const button = document.getElementById('spawnChampionBtn');
    if (!button) return;

    // Update text with current cost
    button.textContent = `Spawn [C]hampion (Cost: ${currentChampionCost})`;

    // Update disabled state and tooltip
    if (championExists) {
        button.disabled = true;
        button.title = "Only one Champion allowed.";
        button.style.cursor = 'not-allowed';
        button.style.opacity = '0.6';
    } else if (score < currentChampionCost) {
        button.disabled = true;
        button.title = `Requires ${currentChampionCost} Gold.`;
        button.style.cursor = 'not-allowed';
        button.style.opacity = '0.6';
    } else {
        button.disabled = false;
        button.title = ""; // Clear tooltip
        button.style.cursor = 'pointer';
        button.style.opacity = '1';
    }
}
	  
        function askMathProblem() {
      // 1. Add '/' to the list of possible operators
      const ops = ['+', '-', '*', '/'];
      const op = ops[Math.floor(Math.random() * ops.length)];

      let a, b;

      // 2. Generate numbers based on the chosen operator
      if (op === '/') {
          // Generate division problems: a / b = c
          // Ensure b > 1 (divisor is 2-10)
          // Ensure c > 1 (result is 2-10)
          let divisor = Math.floor(Math.random() * 9) + 2; // b = Divisor (2 to 10) - Avoids 1
          let result = Math.floor(Math.random() * 9) + 2;  // c = Result (2 to 10)
          a = divisor * result; // Calculate a = b * c
          b = divisor;          // Assign divisor to b
      } else {
          // Generate numbers for +, -, * as before
          a = Math.floor(Math.random() * 10) + 1;
          b = Math.floor(Math.random() * 10) + 1;

          // Ensure subtraction is not negative
          if (op === '-' && a < b) {
              [a, b] = [b, a];
          }
      }

      currentOperands = [a, b];
      currentOperator = op;

           // 3. Determine if the problem is "Hard" (for displaying bonus text)
      // Aligned with operations giving significant gold bonuses
      const isHard =
           // Non-trivial Multiplication (excludes *1, *10)
           (op === '*' && a !== 1 && b !== 1 && a !== 10 && b !== 10) ||
           // Any Division
           (op === '/') ||
           // Subtraction with large first number (as previously defined)
           (op === '-' && a > 15);
           // Note: Large additions aren't marked "Hard" by default here, focus on operator bonus types

      // 4. Construct problem string and calculate answer
      const problemStr = `${a} ${op} ${b}`;
      currentAnswer = eval(problemStr);

      // --- Display logic remains the same ---
      const container = document.getElementById('mathProblem');
      container.innerHTML = `<form id="mathForm">
        <span>${problemStr} = ?</span>
        ${isHard ? '<span style="color:gold; font-weight:bold; margin-left: 10px;">ðŸ’° Bonus!</span>' : ''}
        <input type="number" id="answerInput" required>
        <button type="submit">Submit</button>
      </form>`;

      document.getElementById('mathForm').addEventListener('submit', submitAnswer);
      setTimeout(() => {
        const input = document.getElementById('answerInput');
        if (input) input.focus();
       }, 50);
    }


    function submitAnswer(event) {
      if (event) event.preventDefault(); // Prevent form reload
      if (!gameRunning) return; // Don't process answers if game over

      const input = document.getElementById('answerInput');
      const value = parseInt(input.value, 10);
      const correctAnswerOverlay = document.getElementById('correctAnswerOverlay');
      const correctAnswerMessage = document.getElementById('correctAnswerMessage');

      if (correctAnswerTimeoutId) {
        clearTimeout(correctAnswerTimeoutId);
        correctAnswerTimeoutId = null;
    }
    if (correctAnswerOverlay) {
        correctAnswerOverlay.style.display = 'none';
    }

      if (!isNaN(value) && value === currentAnswer) {
        // Correct answer
        let baseGold = 5;
        let operatorBonus = 0;
        if (currentOperator === '*') operatorBonus = 10;
        else if (currentOperator === '-') operatorBonus = 2;
	else if (currentOperator === '/') operatorBonus = 20;

        let operandBonus = 0;
        if (currentOperands[0] > 8 || currentOperands[1] > 8) operandBonus += 3;
        if (currentOperands[0] + currentOperands[1] > 15) operandBonus += 3;

        let totalGold = baseGold + operatorBonus + operandBonus;

        score += totalGold;
        mathScore += totalGold; // Use the same value for simplicity, or calculate differently

        updateScoreDisplay();
	playSound(sndMathCorrect);
        // Optional: Visual feedback for correct answer
        document.getElementById('mathProblem').style.backgroundColor = 'lightgreen';
        setTimeout(() => { document.getElementById('mathProblem').style.backgroundColor = ''; }, 200);

      } else {
         // Optional: Visual feedback for incorrect answer
	playSound(sndMathIncorrect);
        document.getElementById('mathProblem').style.backgroundColor = 'lightcoral';
        setTimeout(() => { document.getElementById('mathProblem').style.backgroundColor = ''; }, 200);
	if (correctAnswerOverlay && correctAnswerMessage) {
            const originalProblem = `${currentOperands[0]} ${currentOperator} ${currentOperands[1]}`;
            correctAnswerMessage.innerHTML = `Incorrect!<br><br>${originalProblem} = ${currentAnswer}`;
            correctAnswerOverlay.style.display = 'flex'; // Make overlay visible (using flex as per CSS)

            // Set timeout to hide the overlay after a delay
            const displayDuration = 2500; // milliseconds (2.5 seconds)
            correctAnswerTimeoutId = setTimeout(() => {
                 if (correctAnswerOverlay) correctAnswerOverlay.style.display = 'none'; // Hide it again
                 correctAnswerTimeoutId = null; // Clear the ID reference
            }, displayDuration);
        }
      }

      // Ask new question regardless of correctness
      input.value = ""; // Clear input
      askMathProblem();
    }

    // --- Unit Classes ---

    class Unit {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'melee', 'archer', 'mage', 'enemy'
        this.radius = (type === 'enemy' ? 12 : 10); // Enemy slightly bigger?
        this.maxHp = (type === 'enemy' ? 80 : 100); // Enemies maybe slightly weaker?
        this.hp = this.maxHp;
        this.target = null;
        this.cooldown = 0; // For attacks/abilities
	this.rallyMultiplier = 1; // Default damage multiplier
	this.isRallyBuffed = false; // <<< ADD THIS
	

        // Type-specific properties
        switch (type) {
          case 'melee':
            this.color = 'blue';
            this.speed = 1.5;
            this.range = 30; // Melee range
            this.attackDamage = 1;
            this.attackCooldown = 30; // frames (0.5s at 60fps)
            break;
          case 'archer':
            this.color = 'purple';
            this.speed = 1.3;
            this.range = 150;
            this.projectileDamage = 3;
            this.attackCooldown = 60; // frames (1s at 60fps)
            break;
          case 'mage': // Base properties if Mage isn't used, overridden by Mage class
            this.color = 'cyan';
            this.speed = 1.2;
            this.range = 100;
            this.attackDamage = 0; // Mages don't attack directly in this setup
            this.attackCooldown = 1000; // Effectively no attack
            break;
          case 'enemy':
            this.color = 'darkred';
            this.speed = 1.0 + Math.random() * 0.4; // Slight speed variation
            this.range = 30; // Enemy melee range
            this.attackDamage = 2;
             this.attackCooldown = 30;
            this.castleDamage = 0.2; // Damage per frame to castle
	    this.bounceVelX = 0; // Current velocity component from bounce X
        this.bounceVelY = 0; // Current velocity component from bounce Y
        this.bounceDecay = 0.95; // Velocity retained each frame (e.g., 0.92 = loses 8% per frame)
            break;
	 case 'champion': // Set defaults here if needed, but constructor overrides
         this.color = CHAMPION_COLOR;
         this.speed = CHAMPION_SPEED;
         this.range = CHAMPION_ATTACK_RANGE;
         this.maxHp = CHAMPION_MAX_HP;
         this.attackDamage = CHAMPION_ATTACK_DAMAGE;
         this.attackCooldown = CHAMPION_ATTACK_COOLDOWN;
         break;
          default:
             this.color = 'grey';
             this.speed = 1;
             this.range = 10;
             this.attackDamage = 0.5;
             this.attackCooldown = 60;
        }
	       // Ensure HP is set correctly based on maxHp
    this.hp = this.maxHp;

      }

      draw() {
        // Body
          // --- START ADDITION: Draw Rally Buff Fading Aura ---
        if (this.isRallyBuffed && this.rallyBuffTimer > 0) {
            // Calculate progress based on the UNIT'S timer
            // Progress goes 1 down to 0 as timer decreases
            const rallyProgress = this.rallyBuffTimer / CHAMPION_RALLY_DURATION;
            // Opacity fades from 0.5 down to 0.2 (same as Champion's aura)
            const rallyOpacity = 0.2 + rallyProgress * 0.3;
            // Use fixed color or make slightly different from Champion's?
            ctx.fillStyle = `rgba(255, 215, 0, ${rallyOpacity})`; // Fading Gold aura fill

            ctx.beginPath();
            // Draw slightly larger than the unit's radius
            ctx.arc(this.x, this.y, this.radius * 1.4, 0, Math.PI * 2);
            ctx.fill();
        }
        // --- END ADDITION ---
	
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.strokeStyle = 'black'; // Outline
        ctx.lineWidth = 1;
        ctx.stroke();

        // Health bar
        const barWidth = this.radius * 2.5;
        const barHeight = 4;
        const barX = this.x - barWidth / 2;
        const barY = this.y - this.radius - 8; // Position above unit
        const healthRatio = Math.max(0, this.hp / this.maxHp);

        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        ctx.fillStyle = healthRatio > 0.5 ? 'lime' : healthRatio > 0.2 ? 'yellow' : 'red';
        ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);

        // The existing ctx.stroke() call later in the function will now use these styles
      }

          update() {
        // --- Initial Checks ---
        if (this.hp <= 0) {
            this.remove();
            return;
        }
        if (this.cooldown > 0) {
            this.cooldown--;
        }

        // --- Mage Specific State Updates (Ran every frame for Mages) ---
        if (this.type === 'mage') {
            if (this.currentMana < this.maxMana) {
                this.currentMana = Math.min(this.maxMana, this.currentMana + this.manaRegenRate);
            }
            if (this.bounceCooldown > 0) { this.bounceCooldown--; }
            if (this.shockwaveActive) {
                this.shockwaveTimer--;
                if (this.shockwaveTimer <= 0) { this.shockwaveActive = false; }
            }
        }

        // --- Determine Movement Intention (targetDX/DY) ---
        let targetDX = 0;
        let targetDY = 0;
        let separationDX = 0;
        let separationDY = 0;

        // --- Find Target (Relevant for most types) ---
        // Find relevant target first
        if (this.type === 'enemy') {
            this.target = this.findNearest(units); // Target player units
        } else if (this.type === 'melee' || this.type === 'archer') {
            this.target = this.findNearest(enemies); // Target enemies
        }
        // Mage target is handled within its own logic block

 // --- START ADDITION: Update Rally Buff Timer ---
        if (this.isRallyBuffed) {
            this.rallyBuffTimer--;
            if (this.rallyBuffTimer <= 0) {
                this.isRallyBuffed = false; // Buff expired
                this.rallyMultiplier = 1; // Reset multiplier
                this.rallyBuffTimer = 0; // Ensure timer is 0
            }
        }
        // --- END ADDITION ---
        // --- Calculate Target/Goal Movement Based on Type ---

        if (this.type === 'enemy') {
            // --- Enemy Logic ---
            const castleDist = this.distanceTo(castle);
            if (this.target) {
                const dist = this.distanceTo(this.target);
                if (dist <= this.range) {
                    this.attack(this.target);
                    targetDX = 0; targetDY = 0; // Stop moving when attacking
                } else {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const targetDist = Math.hypot(dx, dy);
                    if (targetDist > 0) { targetDX = (dx / targetDist); targetDY = (dy / targetDist); }
                }
            } else if (castleDist <= this.range + castle.width / 2) {
                if (castle.hp > 0) {
                    castle.hp -= this.castleDamage;
                    if (castle.hp <= 0) { gameOver(); return; }
                }
                targetDX = 0; targetDY = 0; // Stop moving
            } else {
                const dx = castle.x - this.x;
                const dy = (castle.y - castle.height / 2 + this.radius) - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) { targetDX = (dx / dist); targetDY = (dy / dist); }
            }
        // --- CORRECTED STRUCTURE FOR PLAYER UNITS ---
        } else if (this.type === 'melee') {
            // --- Melee Logic ---
            if (this.target) {
                const dist = this.distanceTo(this.target);
                if (dist <= this.range) {
                    this.attack(this.target);
                    targetDX = 0; targetDY = 0;
                } else {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const targetDist = Math.hypot(dx, dy);
                    if (targetDist > 0) { targetDX = (dx / targetDist); targetDY = (dy / targetDist); }
                }
            } else {
                targetDX = 0; targetDY = 0; // No target, stand still
            }
        } else if (this.type === 'archer') {
            // --- Archer Logic ---
             if (this.target) {
                 const dist = this.distanceTo(this.target);
                 const idealDist = this.range * 0.8;
                 if (dist < idealDist) {
                     const dx = this.x - this.target.x;
                     const dy = this.y - this.target.y;
                     const fleeDist = Math.hypot(dx, dy);
                     if (fleeDist > 0) { targetDX = (dx / fleeDist); targetDY = (dy / fleeDist); }
                     if (dist <= this.range) this.shoot(this.target);
                 } else if (dist <= this.range) {
                     this.shoot(this.target);
                     targetDX = 0; targetDY = 0;
                 } else {
                     const dx = this.target.x - this.x;
                     const dy = this.target.y - this.y;
                     const targetDist = Math.hypot(dx, dy);
                     if (targetDist > 0) { targetDX = (dx / targetDist); targetDY = (dy / targetDist); }
                 }
            } else {
                targetDX = 0; targetDY = 0; // No target, stand still
            }
                   } else if (this.type === 'mage') {
            // --- Mage Logic ---
            // NOTE: Core state updates (mana regen, cooldowns, shockwave timer) happen at the start of Unit.update

            // --- STATE TRANSITION: Should we ENTER the 'Waiting for Full Mana' state? ---
            // Check if mana just dropped below threshold AND we are not already waiting
            if (!this.isFleeingOOM && this.currentMana < this.lowManaThreshold) {
                 this.isFleeingOOM = true; // Enter the waiting state
                 this.target = null; // Clear offensive target
                 // console.log(`Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}) ENTERED Waiting State (Low Mana).`);
            }

            // --- Primary State Check: Are we currently WAITING FOR FULL MANA? ---
            if (this.isFleeingOOM) {
                // --- ACTION: Waiting for Mana ---

                // A. Check if mana is fully restored to EXIT the state
                if (this.currentMana >= this.maxMana) {
                    this.isFleeingOOM = false; // Exit waiting state
                    // console.log(`Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}) EXITED Waiting State (Mana Full).`);
                    targetDX = 0; targetDY = 0; // Stop moving for this frame
                    // Normal logic will apply next frame
                } else {
		    this.manaChargeAnimTimer = (this.manaChargeAnimTimer + 1) % this.manaChargeAnimDuration;
                    // B. STILL Waiting: Mana is not full. Determine movement based on threats.
                    let fleeTarget = null;
                    let closestEnemyDist = Infinity;
                    const fleeCheckRadius = 120;

                    for (const enemy of enemies) { // Find nearest threat
                        if (enemy.hp <= 0) continue;
                        const d = this.distanceTo(enemy);
                        if (d < fleeCheckRadius && d < closestEnemyDist) {
                            closestEnemyDist = d;
                            fleeTarget = enemy;
                        }
                    }

                    // Set movement: Flee if threat found, otherwise stand still
                    if (fleeTarget) {
                        const dx = this.x - fleeTarget.x;
                        const dy = this.y - fleeTarget.y;
                        const fleeDist = Math.hypot(dx, dy);
                        if (fleeDist > 0) { targetDX = (dx / fleeDist); targetDY = (dy / fleeDist); }
                        else { targetDX = (Math.random() - 0.5); targetDY = (Math.random() - 0.5); }
                         // console.log(`Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}) is WAITING and FLEEING.`);
                    } else {
                        targetDX = 0; // Stand still if waiting and no threat
                        targetDY = 0;
                        // console.log(`Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}) is WAITING and IDLE.`);
                    }
                    // CRITICAL: No healing/bouncing/move-to-heal while in this state.
                }

            } else {
                 // --- ACTION: Normal Operation (Not Waiting for Full Mana) ---
                 // We only reach here if isFleeingOOM is false.

                // Find target for bounce check
                this.target = this.findNearest(enemies);

                // Attempt abilities
                this.healNearbyUnits(); // Checks mana internally
                if (this.bounceCooldown <= 0) {
                    this.triggerBounceOff(); // Checks mana internally via performBounce
                }

                // Determine movement goal if not currently being bounced
                const isBouncing = (Math.abs(this.bounceVelX) > 0.01 || Math.abs(this.bounceVelY) > 0.01);
                if (!isBouncing) {
                    const moveGoal = this.findHealingTargetMovement();
                    if (moveGoal) {
                        targetDX = moveGoal.dx;
                        targetDY = moveGoal.dy;
                    }
                }
                // Else: Bouncing handles movement, or stand still if no heal target
            } // End of main state check (isFleeingOOM or not)
        } // --- End Mage Logic Block ---
        // --- END CORRECTED STRUCTURE ---

        // --- Calculate Separation Force ---
        // (This part remains the same)
        const nearbyUnits = (this.type === 'enemy' ? [...units, ...enemies] : [...units, ...enemies]);
        for (const other of nearbyUnits) {
            if (other === this || other.hp <= 0) continue;
            const dist = this.distanceTo(other);
            if (dist > 0 && dist < SEPARATION_DISTANCE) {
                const pushX = this.x - other.x;
                const pushY = this.y - other.y;
                const strength = SEPARATION_STRENGTH * (1 - dist / SEPARATION_DISTANCE);
                separationDX += (pushX / dist) * strength;
                separationDY += (pushY / dist) * strength;
            }
        }

        // --- Apply Movement Logic ---
        // (This part remains the same - handles bounce vs normal movement)
        let isBouncing = (Math.abs(this.bounceVelX) > 0.01 || Math.abs(this.bounceVelY) > 0.01);
        let moveX = 0;
        let moveY = 0;

        if (isBouncing) {
            this.bounceVelX *= this.bounceDecay;
            this.bounceVelY *= this.bounceDecay;
            moveX = this.bounceVelX;
            moveY = this.bounceVelY;
            if (Math.hypot(this.bounceVelX, this.bounceVelY) < 0.1) {
                this.bounceVelX = 0;
                this.bounceVelY = 0;
            }
        }

        if (!isBouncing) {
            const normalDX = targetDX + separationDX;
            const normalDY = targetDY + separationDY;
            const normalDist = Math.hypot(normalDX, normalDY);
            if (normalDist > 0) {
                moveX += (normalDX / normalDist) * this.speed;
                moveY += (normalDY / normalDist) * this.speed;
            }
        }

        this.x += moveX;
        this.y += moveY;

        // --- Post-Movement Actions ---
        this.enforceBounds();

    } // End of update() method - Ensure this brace matches the 'update() {' at the start
	    
      findNearest(targets) {
        let minDist = Infinity;
        let nearest = null;
        for (const t of targets) {
            if (t.hp <= 0) continue; // Ignore dead targets
            const d = this.distanceTo(t);
            if (d < minDist) {
                minDist = d;
                nearest = t;
            }
        }
        return nearest;
      }

      distanceTo(other) {
          let otherX, otherY;
          if (other === castle) {
              // Find closest point on castle rectangle to the unit's center
              const left = castle.x - castle.width / 2;
              const right = castle.x + castle.width / 2;
              const top = castle.y - castle.height / 2;
              const bottom = castle.y + castle.height / 2;
              otherX = Math.max(left, Math.min(this.x, right));
              otherY = Math.max(top, Math.min(this.y, bottom));
          } else {
               if (!other || typeof other.x === 'undefined' || typeof other.y === 'undefined') {
                   // console.warn("Invalid target in distanceTo:", other);
                   return Infinity; // Avoid errors with invalid targets
               }
              otherX = other.x;
              otherY = other.y;
          }
          const dx = this.x - otherX;
          const dy = this.y - otherY;
          return Math.hypot(dx, dy);
      }

           attack(target) {
        // Check if attack is possible (cooldown ready, valid target with HP)
        if (this.cooldown <= 0 && target && target.hp > 0) {

            // --- START FIX: Ensure oldHp is defined here ---
            const oldHp = target.hp; // Store target's HP *before* dealing damage
            // --- END FIX ---
	    const damageDealt = this.attackDamage * this.rallyMultiplier;
          target.hp -= damageDealt;

            // Trigger damage flash
            target.damageFlashTimer = FLASH_DURATION;

            // Reset attacker's cooldown
            this.cooldown = this.attackCooldown;

            // Play hit sound only if damage was actually dealt (target hp decreased)
            // Now 'oldHp' is guaranteed to be defined in this scope
            if (target.hp < oldHp) {
                 playSound(sndMeleeHit);
            }

            // Check if the target died from this attack
             if (target.hp <= 0) {
                 this.target = null; // Clear attacker's target reference if target died
             }
        }
        // Note: No 'else' block needed here unless you want specific logging for failed attacks
      }

      shoot(target) {
        if (this.cooldown <= 0 && target && target.hp > 0) {
          projectiles.push(new Projectile(this.x, this.y, target, this.projectileDamage, this)); // Pass damage and owner
          this.cooldown = this.attackCooldown;
	  playSound(sndArcherFire);
        }
      }

      enforceBounds() {
        // Keep units fully within the canvas, respecting SAFE_MARGIN
        // Use SAFE_MARGIN directly as the minimum boundary
        const minX = SAFE_MARGIN;
        const minY = SAFE_MARGIN;
        const maxX = canvas.width - SAFE_MARGIN;
        const maxY = canvas.height - SAFE_MARGIN;

        // Clamp the unit's CENTER position
        this.x = Math.max(minX, Math.min(this.x, maxX));
        this.y = Math.max(minY, Math.min(this.y, maxY));

        // Note: If a unit is pushed exactly to the margin, its edge
        // might still slightly overlap if radius > SAFE_MARGIN, but
        // its center will be kept within the safe zone.
        // For health bars always visible, ensure SAFE_MARGIN is large enough
        // (e.g., > unit radius + health bar height + buffer).
        // Current SAFE_MARGIN = 40 should be sufficient.
      }

      remove() {
        const list = (this.type === 'enemy' ? enemies : units);
        const idx = list.indexOf(this);
        if (idx !== -1) {
        // --- START ADDITION ---
        // Check if the removed unit is the Champion
        if (this instanceof Champion) {
            championExists = false; // Update the global flag
            console.log("Champion removed, flag set to false."); // Debug log
            updateChampionButtonDisplay(); // Update button state immediately
        }
        // --- END ADDITION ---
		list.splice(idx, 1);
      }
      }

      // Placeholder methods for Mage - will be overridden but prevent errors if called on base Unit
      updateMageSpecifics() { }
      findHealingTargetMovement() { return null; }

    } // End of Unit class

    class Champion extends Unit {
    constructor(x, y) {
        super(x, y, 'champion'); // Call base class constructor

        // --- Assign Core Stats from Constants ---
        this.radius = CHAMPION_RADIUS;
        this.color = CHAMPION_COLOR;
        this.maxHp = CHAMPION_MAX_HP;
        this.hp = this.maxHp;
        this.speed = CHAMPION_SPEED;
        this.range = CHAMPION_ATTACK_RANGE; // Melee attack range
        this.attackDamage = CHAMPION_ATTACK_DAMAGE;
        this.attackCooldownBase = CHAMPION_ATTACK_COOLDOWN; // Store base cooldown
        this.cooldown = 0; // Use the standard cooldown timer for basic attacks
	this.targetAngle = 0; // Initialize angle (e.g., facing right)

        // --- Ability State & Timers ---
        this.rallyCooldownTimer = 0; // Time until Rally Cry can be used again
        this.slamCooldownTimer = 0;  // Time until Repulsion Slam can be used again
        this.rallyDurationTimer = 0; // How long the current rally buff lasts
        this.rallyBuffAppliedTo = new Set(); // Tracks units currently buffed by this champ

        // --- Slam Animation State (Similar to Mage Shockwave) ---
        this.slamAnimActive = false;
        this.slamAnimTimer = 0;
        this.slamAnimDuration = 40; // Duration of slam visual effect (frames)
        this.slamAnimMaxRadius = CHAMPION_SLAM_EFFECT_RANGE; // Visual expands to effect range

	// --- START ADDITION: Fist Animation State ---
        this.isLeftFistPunching = false;
        this.isRightFistPunching = false;
        this.fistPunchTimer = 0; // Use one timer, activate one fist at a time
        this.fistPunchDuration = 15; // Duration of punch animation in frames (short!)
        this.fistPunchExtension = this.radius * 0.7; // How far the fist moves forward
        this.nextPunchIsLeft = true; // Start with left fist
        // --- END ADDITION ---
    }

    // --- Champion Update Logic (Overrides Unit.update partially) ---
    update() {
        // --- Initial Checks ---
        if (this.hp <= 0) {
            this.remove(); // Calls the Unit.remove(), which should handle championExists flag
            return;
        }

        // --- Tick Down Timers ---
        // Basic attack cooldown
        if (this.cooldown > 0) {
            this.cooldown--;
        }
        // Rally ability cooldown
        if (this.rallyCooldownTimer > 0) {
            this.rallyCooldownTimer--;
        }
        // Slam ability cooldown
        if (this.slamCooldownTimer > 0) {
            this.slamCooldownTimer--;
        }
        // Rally buff duration (if active)
        if (this.rallyDurationTimer > 0) {
            this.rallyDurationTimer--;
            if (this.rallyDurationTimer <= 0) {
                this.removeRallyBuff(); // Buff expired
            }
        }
        // Slam animation timer (if active)
        if (this.slamAnimActive) {
            this.slamAnimTimer--;
            if (this.slamAnimTimer <= 0) {
                this.slamAnimActive = false;
            }
        }

	 // --- START ADDITION: Update Fist Animation Timer ---
            if (this.fistPunchTimer > 0) {
                this.fistPunchTimer--;
                if (this.fistPunchTimer <= 0) {
                    // Animation finished, reset flags
                    this.isLeftFistPunching = false;
                    this.isRightFistPunching = false;
                    // console.log("Punch Animation Ended"); // Debug
                }
            }
            // --- END ADDITION ---

        // --- Ability Trigger Logic ---
        // Try to use Rally Cry if ready
        if (this.rallyCooldownTimer <= 0) {
		 let allyInRange = false;
                // Check if at least one OTHER friendly unit is within rally range
                for (const unit of units) {
                    // Check if it's not self AND it's within range
                    if (unit !== this && this.distanceTo(unit) < CHAMPION_RALLY_RANGE) {
                         // Optionally add: && !(unit instanceof Champion) if >1 champ possible later
                        allyInRange = true;
                        break; // Found one ally, no need to check further
                    }
                }

                // Also check if any enemies are present on the map
                const enemiesPresent = enemies.some(enemy => enemy.hp > 0);

                // Trigger rally only if cooldown ready, an ally is in range, AND an enemy exists
                if (allyInRange && enemiesPresent) {
                     this.performRally();
                }
	}
        // Try to use Repulsion Slam if ready and enemy is close enough
        if (this.slamCooldownTimer <= 0) {
            // Check for nearby enemies to trigger the slam
            let enemiesInRangeCount = 0;
                for (const enemy of enemies) {
                    if (enemy.hp > 0 && this.distanceTo(enemy) < CHAMPION_SLAM_TRIGGER_RANGE) {
                        enemiesInRangeCount++;
                    }
                }

                // Trigger only if enough enemies are nearby
                if (enemiesInRangeCount >= 5) {
                     this.performSlam(); // Call performSlam if condition met
                }
        }

        // --- Movement & Attack Logic (Standard Melee Behavior) ---
        let targetDX = 0;
        let targetDY = 0;
        this.target = this.findNearest(enemies); // Find closest enemy

        if (this.target) {
	    const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const targetDist = Math.hypot(dx, dy); // Calculate distance using hypot
	     if (targetDist > 0) {
                // Calculate angle from Champion to Target in radians
                this.targetAngle = Math.atan2(dy, dx);
		console.log(`Champion Angle Updated: ${this.targetAngle.toFixed(2)} radians`); 
            }
            if (targetDist <= this.range) {
                this.attack(this.target); // Attack if in range (uses standard cooldown)
                targetDX = 0; targetDY = 0; // Stop moving
            } else { // Move towards target
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const targetDist = Math.hypot(dx, dy);
                if (targetDist > 0) {
                    targetDX = (dx / targetDist);
                    targetDY = (dy / targetDist);
                }
            }
        } else {
            targetDX = 0; targetDY = 0; // No target, stand still
        }


        // --- Calculate Separation Force (Copied from Unit.update) ---
        let separationDX = 0;
        let separationDY = 0;
        const nearbyUnits = [...units, ...enemies]; // Check against all units
        for (const other of nearbyUnits) {
          if (other === this || other.hp <= 0) continue;
          const dist = this.distanceTo(other);
          if (dist > 0 && dist < SEPARATION_DISTANCE) { // Use global SEPARATION_DISTANCE
            const pushX = this.x - other.x;
            const pushY = this.y - other.y;
            const strength = SEPARATION_STRENGTH * (1 - dist / SEPARATION_DISTANCE); // Use global SEPARATION_STRENGTH
            separationDX += (pushX / dist) * strength;
            separationDY += (pushY / dist) * strength;
          }
        }

        // --- Apply Movement Logic (Copied & Adapted from Unit.update) ---
        // Note: Champions are not currently affected by Mage bounce, so no bounceVel check needed here
        // If they could be bounced later, add bounce logic back here.
        let moveX = 0;
        let moveY = 0;

        const normalDX = targetDX + separationDX; // Combine target intent with separation
        const normalDY = targetDY + separationDY;
        const normalDist = Math.hypot(normalDX, normalDY);
        if (normalDist > 0) {
            moveX = (normalDX / normalDist) * this.speed; // Apply speed scaling
            moveY = (normalDY / normalDist) * this.speed;
        }

        // Apply final calculated movement
        this.x += moveX;
        this.y += moveY;

        // --- Post-Movement Actions ---
        this.enforceBounds();
    } // End of update()

    // --- Standard Attack (Overrides Unit.attack if needed, but logic is similar) ---
    attack(target) {
        // Uses the standard Unit cooldown timer 'this.cooldown'
        if (this.cooldown <= 0 && target && target.hp > 0) {
            const oldHp = target.hp;
            // Apply base damage (rallyMultiplier is applied in Unit class potentially)
            // Assuming Unit.attack handles rallyMultiplier, otherwise add '* this.rallyMultiplier'
            target.hp -= this.attackDamage; // Apply Champion's damage
            target.damageFlashTimer = FLASH_DURATION; // Use global FLASH_DURATION
            this.cooldown = this.attackCooldownBase; // Reset basic attack cooldown

	    // --- START ADDITION: Trigger Punch Animation ---
                // Only trigger if not already punching
                if (!this.isLeftFistPunching && !this.isRightFistPunching) {
                    this.fistPunchTimer = this.fistPunchDuration; // Start animation timer
                    if (this.nextPunchIsLeft) {
                        this.isLeftFistPunching = true;
                        // console.log("Left Punch Triggered"); // Debug
                    } else {
                        this.isRightFistPunching = true;
                        // console.log("Right Punch Triggered"); // Debug
                    }
                    this.nextPunchIsLeft = !this.nextPunchIsLeft; // Alternate for next time
                }
                // --- END ADDITION ---

            if (target.hp < oldHp) {
                 playSound(sndMeleeHit); // Use standard melee hit sound? Or unique champ sound?
            }
             if (target.hp <= 0) {
                 this.target = null; // Clear target if it died
             }
        }
    }

    // --- Ability 1: Rallying Cry ---
    performRally() {
        // console.log("Champion: Rallying Cry!"); // Debug
        this.rallyCooldownTimer = CHAMPION_RALLY_COOLDOWN; // Reset cooldown
        this.rallyDurationTimer = CHAMPION_RALLY_DURATION; // Start buff duration
        this.removeRallyBuff(); // Clear any previous buff just in case
        this.rallyBuffAppliedTo.clear(); // Ensure set is empty

	playSound(sndRallyCry);

        // Find nearby allies and apply buff
        for (const unit of units) {
             // Don't buff self, don't buff other champions (if ever possible), only buff allies in range
            if (unit !== this && !(unit instanceof Champion) && this.distanceTo(unit) < CHAMPION_RALLY_RANGE) {
                // Assuming Unit class has rallyMultiplier property
                unit.rallyMultiplier = 1 + CHAMPION_RALLY_BUFF_PERCENT;
                this.rallyBuffAppliedTo.add(unit); // Track who got buffed
		 unit.rallyBuffTimer = CHAMPION_RALLY_DURATION; 
		unit.isRallyBuffed = true; // <<< SET FLAG
                 // Add visual indicator to buffed units? (e.g., brief color change)
                 // unit.healFlashTimer = FLASH_DURATION / 2; // Quick blue flash?
            }
        }
    }

    // --- Helper to Remove Rally Buff ---
    removeRallyBuff() {
        // console.log("Champion: Rally Buff Expired."); // Debug
        this.rallyBuffAppliedTo.forEach(unit => {
            if (unit) { // Check if unit still exists
                unit.rallyMultiplier = 1; // Reset multiplier
		unit.isRallyBuffed = false; // <<< RESET FLAG
                 // Remove visual indicator?
            }
        });
        this.rallyBuffAppliedTo.clear(); // Clear the tracking set
    }

    // --- Ability 2: Repulsion Slam ---
    performSlam() {
        // console.log("Champion: Repulsion Slam!"); // Debug
        this.slamCooldownTimer = CHAMPION_SLAM_COOLDOWN; // Reset cooldown

        // Trigger visual effect
        this.slamAnimActive = true;
        this.slamAnimTimer = this.slamAnimDuration;
        playSound(sndSlam);

        // Find nearby enemies and apply effects
        for (const enemy of enemies) {
            if (enemy.hp <= 0) continue; // Skip dead enemies

            const dist = this.distanceTo(enemy);
            if (dist < CHAMPION_SLAM_EFFECT_RANGE) {
                // 1. Apply Damage
                enemy.hp -= CHAMPION_SLAM_DAMAGE;
                enemy.damageFlashTimer = FLASH_DURATION; // Trigger red flash

                // 2. Apply Bounce Velocity
                if (dist > 0) { // Avoid division by zero if exactly on top
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const normalizedX = dx / dist;
                    const normalizedY = dy / dist;
                    // Apply bounce velocity (uses variables on the enemy Unit)
                    enemy.bounceVelX = normalizedX * CHAMPION_SLAM_INITIAL_SPEED;
                    enemy.bounceVelY = normalizedY * CHAMPION_SLAM_INITIAL_SPEED;
                }
            }
        }
         // Check HP again after applying damage (in case they died) - handled by enemy's own update loop
    }

    // --- Draw Champion (Override Unit.draw) ---
    draw() {
        // 1. Draw the base unit (circle, HP bar) using Unit's draw method
        super.draw(); // Calls Unit.prototype.draw()

        // --- Draw Champion Specifics ---
        const crownSize = this.radius * 0.5;
        const crownY = this.y - this.radius - 8 - 5; // Above HP bar (-8) + 5px gap
        const fistRadius = this.radius * 0.3;
        const fistOffsetX = this.radius * 1.3;
        const fistOffsetY = this.radius * 0.2; // Slightly below center vertically
	const fistAngleOffset = Math.PI / 2.5;

	// --- START MODIFICATION: Calculate Fist Positions using Angle ---
        // Left Fist Position
        const leftFistAngle = this.targetAngle + fistAngleOffset;
        const leftFistX = this.x + Math.cos(leftFistAngle) * fistOffsetX;
        const leftFistY = this.y + Math.sin(leftFistAngle) * fistOffsetX;

        // Right Fist Position
        const rightFistAngle = this.targetAngle - fistAngleOffset;
        const rightFistX = this.x + Math.cos(rightFistAngle) * fistOffsetX;
        const rightFistY = this.y + Math.sin(rightFistAngle) * fistOffsetX;
        // --- END MODIFICATION ---

	// --- START FIX: Initialize draw positions BEFORE animation check ---
            let drawLeftFistX = LeftFistX;
            let drawLeftFistY = LeftFistY;
            let drawRightFistX = RightFistX;
            let drawRightFistY = RightFistY;
            // --- END FIX ---

	// --- START MODIFICATION: Animate Punching Fist ---
            if (this.isLeftFistPunching || this.isRightFistPunching) {
                // Calculate animation progress: 0 -> 1 (extend), 1 -> 0 (retract)
                const halfDuration = this.fistPunchDuration / 2;
                let punchProgress = 0;
                if (this.fistPunchTimer > halfDuration) {
                    // Extending phase (timer goes from Duration down to halfDuration)
                    punchProgress = 1.0 - (this.fistPunchTimer - halfDuration) / halfDuration;
                } else {
                    // Retracting phase (timer goes from halfDuration down to 0)
                    punchProgress = this.fistPunchTimer / halfDuration;
                }
                punchProgress = Math.max(0, Math.min(1, punchProgress)); // Clamp between 0 and 1

                // Calculate extension offset along the target direction
                const offsetX = Math.cos(this.targetAngle) * this.fistPunchExtension * punchProgress;
                const offsetY = Math.sin(this.targetAngle) * this.fistPunchExtension * punchProgress;

                // Apply offset to the punching fist
                if (this.isLeftFistPunching) {
                    drawLeftFistX += offsetX;
                    drawLeftFistY += offsetY;
                } else if (this.isRightFistPunching) {
                    drawRightFistX += offsetX;
                    drawRightFistY += offsetY;
                }
            }
            // --- END MODIFICATION ---
	    
       // 2. Draw Crown (Revised for better shape)
        ctx.fillStyle = 'yellow';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.beginPath();

        // Define points relative to center top
        const crownBaseY = crownY; // Use the calculated Y position
        const crownTopY = crownY - crownSize; // Top of middle spike
        const crownSidePointY = crownY - crownSize * 0.75; // Top of side spikes (slightly lower)

        const baseHalfWidth = crownSize / 2;
        const middleSpikeHalfWidth = crownSize * 0.3; // Give middle spike some base width
        const sideSpikeOffset = crownSize * 0.6; // How far side spikes are from center

        // Start at bottom left corner
        ctx.moveTo(this.x - baseHalfWidth, crownBaseY);

        // Left spike
        ctx.lineTo(this.x - sideSpikeOffset, crownSidePointY); // Up to left spike top
        ctx.lineTo(this.x - middleSpikeHalfWidth, crownBaseY); // Down to left base of middle spike

        // Middle spike
        ctx.lineTo(this.x, crownTopY); // Up to middle spike top
        ctx.lineTo(this.x + middleSpikeHalfWidth, crownBaseY); // Down to right base of middle spike

        // Right spike
        ctx.lineTo(this.x + sideSpikeOffset, crownSidePointY); // Up to right spike top
        ctx.lineTo(this.x + baseHalfWidth, crownBaseY); // Down to bottom right corner

        // Close path back to start (optional, fill usually closes it)
        ctx.closePath();

        ctx.fill();
        ctx.stroke();

        // 3. Draw Floating Fists
        ctx.fillStyle = this.color; // Use Champion's main color
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        // Left Fist
        ctx.beginPath();
         ctx.arc(leftFistX, leftFistY, fistRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Right Fist
        ctx.beginPath();
        ctx.arc(rightFistX, rightFistY, fistRadius, 0, Math.PI * 2); 
        ctx.fill();
        ctx.stroke();

        // 4. Draw Slam Animation (if active) - Similar to Mage bounce shockwave
        if (this.slamAnimActive) {
            const progress = 1.0 - (this.slamAnimTimer / this.slamAnimDuration);
            const currentRadius = this.slamAnimMaxRadius * progress;
            const opacity = 1.0 - progress;
            const safeOpacity = Math.max(0, opacity);
            // Use a different color, e.g., white/yellow
            ctx.strokeStyle = `rgba(255, 255, 150, ${safeOpacity})`; // Pale Yellow
            ctx.lineWidth = Math.max(1, 6 * (1.0 - progress) + 1); // Thicker effect?
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            if (safeOpacity > 0.05) {
                ctx.stroke();
            }
        }

        // 5. Draw Rally Aura (Optional - if active)
        if (this.rallyDurationTimer > 0) {
             const rallyProgress = this.rallyDurationTimer / CHAMPION_RALLY_DURATION; // 1 down to 0
             const rallyOpacity = 0.2 + rallyProgress * 0.3; // Fades from 0.5 to 0.2
             ctx.fillStyle = `rgba(255, 215, 0, ${rallyOpacity})`; // Fading Gold aura fill?
             ctx.beginPath();
             ctx.arc(this.x, this.y, this.radius * 1.2, 0, Math.PI * 2); // Aura slightly larger than unit
             ctx.fill();
        }

    } // End of draw()

} // End of Champion Class

    // --- Mage Class ---
    class Mage extends Unit {
      constructor(x, y) {
        super(x, y, 'mage'); // Call base class constructor
        // Override or set Mage-specific properties
        this.color = '#2ecc71'; // Emerald green
        this.speed = 1.1;
        this.range = 120; // Range for abilities, not direct attack
        this.maxHp = 50; // Mages might be slightly squishier
        this.hp = this.maxHp;
	      
        this.isFleeingOOM = false; // True if currently fleeing due to low mana
        this.healRate = 0.16; // HP per frame
        this.healRange = 40;
        this.bounceCooldownMax = 500; // 360 value is 3 seconds at 60fps
        this.bounceCooldown = 0;
        this.bounceTriggerRange = 70; // Enemies within this range can trigger the bounce
        this.bounceEffectRange = 200; // Enemies within this range are affected when bounce triggers
        this.bounceForce = 150; // How far enemies are pushed
	this.bounceInitialSpeed = 9; // Adjust this value to control initial push speed

	this.shockwaveActive = false;
        this.shockwaveTimer = 0; // Counts down animation frames
        this.shockwaveDuration = 30; // Duration in frames (e.g., 0.5 seconds at 60fps)
        this.shockwaveMaxRadius = this.bounceEffectRange; // Expand out to the effect range

	this.manaChargeAnimTimer = 0; // Timer cycles continuously for pulsing effect
        this.manaChargeAnimDuration = 60; // Duration of one pulse cycle in frames (e.g., 1 second)
        this.manaChargeMaxRadius = this.radius * 1.8; // Max size of the blue pulse (smaller than bounce)
        this.manaChargeBaseOpacity = 0.5; // Base opacity for the blue pulse

	this.maxMana = 100;
        this.currentMana = this.maxMana; // Start full
        this.manaRegenRate = 0.15; // Mana per frame (e.g., 0.15 * 60 = 9 mana/sec)

        this.bounceManaCost = 35; // Cost to perform bounce
        this.healManaCost = 0.8; // Cost per successful heal tick applied
        this.lowManaThreshold = this.healManaCost; // Flee if mana is below this
      }

      // Called BY the base Unit.update() method specifically for mages
            // Called BY the base Unit.update() method specifically for mages
        updateMageSpecifics() {
              // --- START MODIFICATION: Add Logging ---
            // Manage the shockwave animation timer if it's active
            if (this.shockwaveActive) {
                // --- DETAILED LOGGING ---
                console.log(`Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}): updateMageSpecifics - shockwave IS active. Timer BEFORE decrement: ${this.shockwaveTimer}`);
                // --- END DETAILED LOGGING ---

                this.shockwaveTimer--; // Decrement the timer each frame

                if (this.shockwaveTimer <= 0) {
                    // --- DETAILED LOGGING ---
                    console.log(`%cMage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}): updateMageSpecifics - Timer reached 0. Setting shockwaveActive to false.`, "color: red;");
                    // --- END DETAILED LOGGING ---
                    this.shockwaveActive = false; // Deactivate the animation when timer runs out
                }
            }
            // --- END MODIFICATION ---
	    // --- START ADDITION: Mana Regeneration ---
            if (this.currentMana < this.maxMana) {
                 this.currentMana = Math.min(this.maxMana, this.currentMana + this.manaRegenRate);
            }
            // --- END ADDITION ---
            // Existing Mage logic (Healing and Bounce Cooldown)
            this.healNearbyUnits();

            if (this.bounceCooldown <= 0) {
                this.triggerBounceOff(); // Check if bounce should be triggered
            } else {
                this.bounceCooldown--; // Count down bounce ability cooldown
            }
        }

            // Provides movement direction towards the "best" target needing healing.
        // Best is determined by a score combining missing health and proximity.
        findHealingTargetMovement() {
            let bestTargetOverall = null;
            let highestScoreOverall = -1;

            // Find the allied unit (not self) with the highest score globally
            for (const unit of units) {
                // Skip self & units at full health
                if (unit === this || unit.hp >= unit.maxHp || unit instanceof Champion) continue;

                const dist = this.distanceTo(unit);
                // Add small amount to distance to prevent division by zero
                const distanceFactor = Math.max(dist, 1.0);
                const missingHp = unit.maxHp - unit.hp;
                const score = missingHp / distanceFactor;

                if (score > highestScoreOverall) {
                    highestScoreOverall = score;
                    bestTargetOverall = unit;
                }
            }

            // If a best target was found anywhere...
            if (bestTargetOverall) {
                const distToBest = this.distanceTo(bestTargetOverall);

                // Move towards it only if it's not already very close (outside ~70% heal range)
                if (distToBest > this.healRange * 0.7) {
                     const dx = bestTargetOverall.x - this.x;
                     const dy = bestTargetOverall.y - this.y;
                     // distToBest is already calculated, use it for normalization
                     if (distToBest > 0) { // Avoid division by zero if somehow target is at exact same spot
                        return { dx: dx / distToBest, dy: dy / distToBest }; // Return normalized direction
                     }
                }
            }

            // If no target found, or target is already close enough, no specific healing movement needed.
            return null;
        }

           // Heals the single "best" target ally (NOT self) within healRange
      // Best is determined by a score combining missing health and proximity.
      healNearbyUnits() {
          let bestTarget = null;
          let highestScore = -1; // Use -1 to ensure any valid target is chosen initially

          // Find the best target unit (NOT self) currently within healRange
          for (const unit of units) {
	
              // Skip self & units at full health
              if (unit === this || unit.hp >= unit.maxHp || unit instanceof Champion) continue;

              const dist = this.distanceTo(unit);

              // Check if IN heal range
              if (dist < this.healRange) {
                  // Calculate score: missing health / distance
                  // Add a small amount to distance to prevent division by zero
                  // and slightly de-prioritize targets right on top of the mage.
                  const distanceFactor = Math.max(dist, 1.0); // Avoid division by zero or tiny distances
                  const missingHp = unit.maxHp - unit.hp;
                  const score = missingHp / distanceFactor;

                  // If this unit has a higher score than the best found so far
                  if (score > highestScore) {
                      highestScore = score;
                      bestTarget = unit;
                  }
              }
          }

          // If a valid target was found within range based on score, heal only that target
          if (bestTarget) {
            // --- START MANA CHECK ---
              // Check if we have enough mana *before* attempting to heal
              if (this.currentMana >= this.healManaCost) {
                   const oldHp = bestTarget.hp;
                   bestTarget.hp = Math.min(bestTarget.hp + this.healRate, bestTarget.maxHp);

                   if (bestTarget.hp > oldHp) {
                       // Healing was successful, now subtract mana
                       this.currentMana -= this.healManaCost; // Subtract cost
                       bestTarget.isBeingHealed = true;
                       playSound(sndHealPulse);
                   }
                   // Else: HP was already max, no mana cost, no sound/flag needed
              } else {
                  // Not enough mana to initiate heal tick (optional: play sound?)
                  // playSound(sndNoMana); // Maybe too noisy if played every frame?
              }
              // --- END MANA CHECK ---
	  }
      }

      triggerBounceOff() {
          let enemyInRange = false;
          for (const enemy of enemies) {
              if (enemy.hp <= 0) continue;
              const dist = this.distanceTo(enemy);
              if (dist < this.bounceTriggerRange) {
                  enemyInRange = true;
                  break;
              }
          }
          if (enemyInRange) {
              this.performBounce();
          }
      }

     performBounce() {
	  // --- START MANA CHECK ---
          if (this.currentMana < this.bounceManaCost) {
              //playSound(sndNoMana); // Play "fizzle" or "error" sound
              return; // Not enough mana, do nothing else
          }
          // Sufficient mana, proceed:
          this.currentMana -= this.bounceManaCost; // Subtract cost
          // --- END MANA CHECK ---
          // --- START ADDITION: Trigger Shockwave ---
          this.shockwaveActive = true;
          this.shockwaveTimer = this.shockwaveDuration;
          // --- DETAILED LOGGING ---
          console.log(`%cBOUNCE TRIGGERED: Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}): shockwaveActive SET to true, shockwaveTimer SET to ${this.shockwaveTimer}`, "color: blue; font-weight: bold;");
          // --- END DETAILED LOGGING ---

            playSound(sndMageBounce);

            // Visual effect for bounce (Original static green circle - KEEP FOR NOW)
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.bounceEffectRange, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(46, 204, 113, 0.2)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(46, 204, 113, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
            // END Static green circle drawing

            // Apply bounce velocity to enemies
            for (const enemy of enemies) {
               if (enemy.hp <= 0) continue;
               const dist = this.distanceTo(enemy);
               if (dist > 0 && dist < this.bounceEffectRange) {
                   const dx = enemy.x - this.x;
                   const dy = enemy.y - this.y;
                   const normalizedX = dx / dist;
                   const normalizedY = dy / dist;
                   enemy.bounceVelX = normalizedX * this.bounceInitialSpeed;
                   enemy.bounceVelY = normalizedY * this.bounceInitialSpeed;
               }
            }
            this.bounceCooldown = this.bounceCooldownMax; // Reset cooldown

        }

        // Mages don't shoot projectiles in this setup
        shoot(target) { } // This is now correctly placed AFTER performBounce closes
        attack(target) { } // Mages don't melee attack

	 draw() {
          // 1. Call the base Unit's draw method to draw body and HP bar
          super.draw(); // Executes Unit.prototype.draw()

          // 2. Draw the Mana Bar below the HP bar
          const manaRatio = Math.max(0, this.currentMana / this.maxMana);
          const barWidth = this.radius * 2.5; // Same width as HP bar
          const barHeight = 4;
          const barX = this.x - barWidth / 2;
          // Position it below the HP bar (HP bar is at y - radius - 8)
          const barY = this.y - this.radius - 8 + barHeight + 2; // Add HP bar height + 2px gap

          ctx.fillStyle = '#333'; // Background
          ctx.fillRect(barX, barY, barWidth, barHeight);
          ctx.fillStyle = '#3498db'; // Blue color for mana
          ctx.fillRect(barX, barY, barWidth * manaRatio, barHeight);
      }
    } // End of Mage Class

    // Ensure CHAMPION_ constants are defined before this class
// Ensure Unit class has 'rallyMultiplier' property (default 1)
	  
    // --- Projectile Class ---
    class Projectile {
      constructor(x, y, target, damage, owner) { // Added damage and owner
        this.x = x;
        this.y = y;
        this.target = target;
        this.damage = damage;
        this.owner = owner; // The unit that fired the projectile
        this.speed = 5;
        this.radius = 4;
        this.color = 'black';
        this.done = false; // Flag for removal
      }

      update() {
        if (this.target.hp <= 0 || !this.target) {
          this.done = true; // Target died or disappeared
          return;
        }

        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const dist = Math.hypot(dx, dy);

        // Check for hit (collision)
        if (dist < this.target.radius + this.radius || dist < this.speed) {
	  const oldHp = this.target.hp; // Store target's HP *before* dealing damage
           // --- START MODIFICATION: Apply Rally Multiplier from Owner ---
            // Ensure owner exists and has the multiplier property, default to 1 otherwise
            const multiplier = (this.owner && typeof this.owner.rallyMultiplier === 'number')
                               ? this.owner.rallyMultiplier
                               : 1;
            const damageDealt = this.damage * multiplier;
            this.target.hp -= damageDealt;
            // --- END MODIFICATION ---
          this.done = true;

	  // --- ADD SOUND ---
     // Play hit sound only if damage was dealt
     if(this.target.hp < oldHp) {
        //playSound(sndArrowHit);
     }
     // --- END SOUND ---
          
                // Ensure the owner unit clears its target if its current target just died
                if (this.owner && this.owner.target === this.target) {
                    this.owner.target = null;
                
           }
        } else {
          // Move towards target
          this.x += (dx / dist) * this.speed;
          this.y += (dy / dist) * this.speed;
        }
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    } // End of Projectile Class

	    // --- START UPDATED HIGH SCORE FUNCTIONS (v9 Syntax) ---

    /**
     * Fetches high scores from Firebase, sorted descending by score.
     * @returns {Promise<Array>} A promise that resolves with an array of score objects.
     */
    async function loadHighScoresFromFirebase() {
        console.log("Loading high scores from Firebase (v9)...");
        // Create the query: order by 'score' descending, limit to MAX_HIGH_SCORES
        const q = query(highScoresCollectionRef, orderBy('score', 'desc'), limit(MAX_HIGH_SCORES));
        try {
            const querySnapshot = await getDocs(q); // Execute the query
            const scores = [];
            querySnapshot.forEach((doc) => {
                // doc.data() contains the fields (name, score, timestamp)
                scores.push({ id: doc.id, ...doc.data() });
            });
            console.log("Loaded scores (v9):", scores.length);
            return scores;
        } catch (error) {
            console.error("Error loading high scores (v9):", error);
            return []; // Return empty array on error
        }
    }

    /**
     * Checks if a score qualifies for the high score list.
     * Assumes 'scores' array is sorted descending.
     * @param {number} score The player's score.
     * @param {Array} currentHighScores The currently loaded high scores.
     * @returns {boolean} True if it's a high score, false otherwise.
     */
    function isHighScore(score, currentHighScores) {
        // This function logic doesn't change based on Firebase version
        if (!currentHighScores || currentHighScores.length === 0) return true; // Qualifies if list is empty

        return currentHighScores.length < MAX_HIGH_SCORES || score > currentHighScores[currentHighScores.length - 1].score;
    }

    /**
     * Saves a new high score to Firebase using v9 syntax.
     * @param {string} name Player's name.
     * @param {number} score Player's score.
     * @returns {Promise<boolean>} A promise that resolves with true on success, false on error.
     */
    async function saveHighScoreToFirebase(name, score) {
        console.log(`Attempting to save score (v9): ${name} - ${score}`);
        // Basic validation (same as before)
        if (!name || typeof name !== 'string' || name.trim().length === 0 || name.length > 49) {
             console.error("Invalid name provided for high score.");
             alert("Please enter a valid name (1-49 characters).");
             return false;
        }
        if (typeof score !== 'number' || score <= 0) {
             console.error("Invalid score provided for high score.");
             return false;
        }

        try {
            // Use addDoc with the collection reference and data object
            const docRef = await addDoc(highScoresCollectionRef, {
                name: name.trim(),
                score: score,
                timestamp: serverTimestamp() // Use the imported serverTimestamp function
            });
            console.log("High score saved successfully with ID: ", docRef.id);
            return true;
        } catch (error) {
            console.error("Error saving high score (v9):", error);
            alert("Could not save high score. Please try again.");
            return false;
        }
    }

    /**
     * Displays the high scores in an HTML element. (No changes needed)
     * @param {Array} scores Array of score objects.
     * @param {string} containerId The ID of the HTML element to display scores in.
     */
    function displayHighScores(scores, containerId) {
        // This function logic remains exactly the same
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '<h3>High Scores:</h3>';
        if (!scores || scores.length === 0) {
            container.innerHTML += '<p>No scores yet!</p>';
            return;
        }

        const list = document.createElement('ol');
        scores.forEach((scoreData, index) => {
            const item = document.createElement('li');
            const nameText = scoreData.name ? scoreData.name.replace(/</g, "<").replace(/>/g, ">") : "???";
            const scoreNum = typeof scoreData.score === 'number' ? scoreData.score : 0;
            // Display timestamp nicely (optional)
            let dateString = '';
            if (scoreData.timestamp && scoreData.timestamp.toDate) { // Check if it's a Firebase timestamp
                 dateString = ` - ${scoreData.timestamp.toDate().toLocaleDateString()}`;
            }
            item.textContent = `${nameText} - ${scoreNum}${dateString}`; // Added optional date
            list.appendChild(item);
        });
        container.appendChild(list);
    }

    // --- END UPDATED HIGH SCORE FUNCTIONS ---
	  
    // --- Game Functions ---

    function spawnUnit(type) {
      if (!gameRunning) return;
       // Only check cap for player units (not 'enemy')
      if (type !== 'enemy') {
          if (units.length >= currentArmyCap) {
              console.log(`Army cap reached (${currentArmyCap}). Cannot spawn ${type}.`);
              // Optional: Add visual feedback - flash the cap button red?
              flashElement(document.getElementById('upgradeCapButton'), 'lightcoral');
              return; // Stop spawning if cap is reached
          }
      }
      const costs = { melee: 10, archer: 15, mage: 50 };
      const cost = costs[type] || 0; // Default cost 0 if type not found

      if (type !== 'enemy') { // Player unit spawn
          if (score < cost) {
	      playSound(sndNoGold);
              console.log(`Not enough gold to spawn ${type}. Need ${cost}, have ${score}`);
               flashElement(getSpawnButtonByType(type), 'lightcoral'); // Helper needed
              return;
          }
          score -= cost;
          updateScoreDisplay();
	  playSound(sndSpawnSuccess); // Play sound on successful spawn
      }

      // Spawn player units near the castle, enemies near the top
      let spawnX, spawnY;
      if (type === 'enemy') {
          spawnX = Math.random() * (canvas.width - SAFE_MARGIN * 2) + SAFE_MARGIN;
          spawnY = SAFE_MARGIN + Math.random() * 50; // Spawn near top edge
      } else {
          // Spawn player units in a zone in front of the castle
          const spawnZoneY = castle.y - castle.height / 2 - 60;
          spawnX = castle.x + (Math.random() - 0.5) * castle.width * 1.5;
          spawnY = spawnZoneY + (Math.random() - 0.5) * 40;
          // Clamp spawn position to be within canvas bounds
          spawnX = Math.max(SAFE_MARGIN, Math.min(spawnX, canvas.width - SAFE_MARGIN));
          spawnY = Math.max(SAFE_MARGIN, Math.min(spawnY, canvas.height - SAFE_MARGIN - castle.height)); // Prevent spawning inside castle visually
      }


      let newUnit;
      if (type === 'mage') {
          newUnit = new Mage(spawnX, spawnY);
      } else { // Melee, Archer, or Enemy
          newUnit = new Unit(spawnX, spawnY, type);
      }

      if (type === 'enemy') {
          enemies.push(newUnit);
	  playSound(sndEnemySpawn);
      } else {
          units.push(newUnit);
      }
    }
	  window.spawnUnit = spawnUnit; // <-- ADD THIS LINE TEMPORARILY


	 function getSpawnButtonByType(type) {
        const buttons = document.querySelectorAll('#controls button');
        if (type === 'melee') return buttons[0];
        if (type === 'archer') return buttons[1];
        if (type === 'mage') return buttons[2];
        return null;
    }

    // General purpose element flasher
    function flashElement(element, flashColor = 'lightcoral', originalColor = null, duration = 200) {
       if (element) {
            const originalBg = originalColor !== null ? originalColor : element.style.backgroundColor;
            element.style.transition = 'background-color 0.1s ease-in-out'; // Ensure transition is set
            element.style.backgroundColor = flashColor;
            setTimeout(() => {
                 // Check element still exists before reverting
                 if(document.body.contains(element)) {
                     element.style.backgroundColor = originalBg;
                 }
            }, duration);
        }
    }
    
     function calculateNextCapUpgradeCost() {
        // Cost increases exponentially based on the number of upgrades already purchased
        const cost = BASE_ARMY_CAP_UPGRADE_COST * Math.pow(ARMY_CAP_UPGRADE_COST_SCALING, armyCapUpgradeLevel);
        return Math.floor(cost); // Use floor to keep costs as integers
    }

    function updateUpgradeButtonDisplay() {
        const button = document.getElementById('upgradeCapButton');
        if (!button) return;

        const nextCost = calculateNextCapUpgradeCost();
        const nextCap = currentArmyCap + ARMY_CAP_INCREASE_PER_UPGRADE;

        button.innerHTML = `[U]pgrade Cap (${currentArmyCap} -> ${nextCap}) (Cost: ${nextCost}ðŸª™)`;
    }

    function upgradeArmyCap() {
        if (!gameRunning) return;

        const cost = calculateNextCapUpgradeCost();

        if (score >= cost) {
            // Affordable: Perform upgrade
            score -= cost;
            currentArmyCap += ARMY_CAP_INCREASE_PER_UPGRADE;
            armyCapUpgradeLevel++; // Increment the level tracker

            console.log(`Army cap upgraded to ${currentArmyCap}. Level: ${armyCapUpgradeLevel}`);

            updateScoreDisplay(); // Update score shown
            updateUpgradeButtonDisplay(); // Update button text for the *next* upgrade

            // Optional: Flash button green on success
             flashElement(document.getElementById('upgradeCapButton'), 'lightgreen', '#d4af37'); // Flash green, revert to gold

        } else {
            // Unaffordable
            console.log(`Not enough gold to upgrade army cap. Need ${cost}, have ${score}`);
            // Optional: Flash button red on failure
            flashElement(document.getElementById('upgradeCapButton'), 'lightcoral', '#d4af37'); // Flash red, revert to gold
        }
    }

	  window.upgradeArmyCap = upgradeArmyCap; // <-- ADD THIS LINE TEMPORARILY
    
     function updateWaveStatusDisplay(message) {
        const statusElement = document.getElementById('waveStatus');
        if (statusElement) {
            statusElement.innerText = message;
        }
    }

    function startNextWave() {
        currentWave++;
        waveState = 'SPAWNING';
	playSound(sndWaveStart);

        // Calculate wave parameters
        enemiesToSpawnThisWave = BASE_ENEMY_COUNT + (currentWave - 1) * ENEMY_COUNT_INCREASE_PER_WAVE;
        waveSpawnInterval = Math.max(MIN_SPAWN_INTERVAL, BASE_SPAWN_INTERVAL - (currentWave - 1) * SPAWN_INTERVAL_DECREASE_PER_WAVE);

        enemiesSpawnedThisWave = 0;
        spawnTimer = waveSpawnInterval; // Start ready to spawn first enemy relatively quickly

        console.log(`Starting Wave ${currentWave}: ${enemiesToSpawnThisWave} enemies, spawn interval ${waveSpawnInterval} frames.`);
        updateWaveStatusDisplay(`Wave ${currentWave} Starting!`);

        // No explicit wave duration timer; wave ends when all enemies are spawned.
        waveTimer = 0; // Reset or repurpose waveTimer if needed later
    }

    function updateWaveLogic() {
        if (!gameRunning) return;

        if (waveState === 'INTERMISSION') {
            waveTimer--; // Countdown intermission timer

            // Display remaining time (optional, convert frames to seconds)
            const secondsLeft = Math.ceil(waveTimer / 60);
            updateWaveStatusDisplay(`Wave ${currentWave} Complete! Next wave in ${secondsLeft}s...`);

            if (waveTimer <= 0) {
                startNextWave();
            }
        } else if (waveState === 'SPAWNING') {
            spawnTimer--; // Countdown timer for next spawn

            if (spawnTimer <= 0 && enemiesSpawnedThisWave < enemiesToSpawnThisWave) {
                spawnUnit('enemy'); // Spawn one enemy
                enemiesSpawnedThisWave++;
                spawnTimer = waveSpawnInterval; // Reset timer for the next spawn

                // Update display (optional)
                updateWaveStatusDisplay(`Wave ${currentWave} | Spawning: ${enemiesSpawnedThisWave} / ${enemiesToSpawnThisWave}`);
            }

            // Check if all enemies for this wave have been spawned
            if (enemiesSpawnedThisWave >= enemiesToSpawnThisWave) {
            	  // Award bonus immediately after last enemy spawns for Wave 1 onwards
            if (currentWave > 0) {
                // Calculate the reward
                const waveReward = WAVE_CLEAR_BASE_GOLD + (currentWave * WAVE_CLEAR_GOLD_PER_WAVE);

                // Add reward to score/gold
                score += waveReward;
                mathScore += WAVE_CLEAR_GOLD_PER_WAVE*2; // Assuming you want to add to both

                // Log feedback to console
                console.log(`Wave ${currentWave} spawning complete! Bonus: +${waveReward} Gold/Score`);

                // Update the score display on the screen
                updateScoreDisplay();

                // Optional: Add a brief visual flash to the score display
                const scoreElement = document.getElementById('scoreDisplay');
                if (scoreElement) {
                    scoreElement.style.transition = 'background-color 0.1s ease-in-out';
                    scoreElement.style.backgroundColor = 'lightgoldenrodyellow';
                    setTimeout(() => {
                        scoreElement.style.backgroundColor = ''; // Revert color
                    }, 200); // Flash duration
                }
            }
                waveState = 'INTERMISSION';
                waveTimer = BASE_INTERMISSION_DURATION; // Start the standard intermission countdown
                console.log(`Wave ${currentWave} spawning complete. Starting intermission.`);
                // Update display immediately for intermission start
                 updateWaveStatusDisplay(`Wave ${currentWave} Complete! Prepare for Wave ${currentWave + 1}...`);
            }
        }
    }

	  function handleKeyPress(event) {
    // Ignore key presses if the game isn't running
    if (!gameRunning) return;

    const key = event.key;
    const lowerKey = key.toLowerCase(); // Use lowercase for checking m, a, g
    const answerInput = document.getElementById('answerInput');
    const isInputFocused = document.activeElement === answerInput;

    // Define keys that are ESSENTIAL for the number input field
    const essentialInputKeys = [
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '-', // Minus sign
        'Backspace', 'Delete',
        'ArrowLeft', 'ArrowRight',
        'Enter', // Allows submitting the form via Enter key
        'Tab'    // Allows standard navigation
        // Add 'Home', 'End' if needed
    ];

    // If the input field is focused AND the key is essential for typing, allow it
    if (isInputFocused && essentialInputKeys.includes(key)) {
        return; // Allow default behavior (typing number, deleting, etc.)
    }

    // Handle the game shortcuts (M, A, G)
    let shortcutUsed = false;
    switch (lowerKey) {
        case 'm': // M key for Melee
            spawnUnit('melee');
            flashButton('melee');
            shortcutUsed = true;
            break;
        case 'a': // A key for Archer
            spawnUnit('archer');
            flashButton('archer');
            shortcutUsed = true;
            break;
        case 'g': // G key for Mage
            spawnUnit('mage');
            flashButton('mage');
            shortcutUsed = true;
            break;
	case 'c': // M key for Melee
            spawnChampion(); // Call the specific spawn function for Champion
                flashButton('champion'); // Update flashButton if needed
                shortcutUsed = true;
            break;
        case 'u': // U key for Upgrade Cap
            upgradeArmyCap(); // Call the upgrade function
            shortcutUsed = true;
            break;
    }

    // If a shortcut key (M, A, G) was just processed, prevent its default action.
    // This should reliably stop 'm', 'a', or 'g' from appearing in the input box
    // if it happened to have focus when the key was pressed.
    if (shortcutUsed) {
        event.preventDefault();
    }
}

 function flashButton(unitType) {
        const buttons = document.querySelectorAll('#controls button');
        let targetButton = null;
        if (unitType === 'melee') targetButton = buttons[0];
        else if (unitType === 'archer') targetButton = buttons[1];
        else if (unitType === 'mage') targetButton = buttons[2];
	  else if (unitType === 'champion' && champButton) targetButton = champButton;

        if (targetButton) {
            const originalColor = targetButton.style.backgroundColor;
            targetButton.style.backgroundColor = 'lightgreen'; // Highlight color
            setTimeout(() => {
                targetButton.style.backgroundColor = originalColor; // Revert color
            }, 150); // Highlight duration (150ms)
        }
    }
	  
    async function gameOver() {
	console.error("!!! GAMEOVER FUNCTION ENTERED !!!"); // Add this line
        if (!gameRunning) return; // Prevent multiple calls
        console.log("GAME OVER");
        gameRunning = false; // Stop game logic
	playSound(sndGameOver);

	const correctAnswerOverlay = document.getElementById('correctAnswerOverlay');
    if (correctAnswerOverlay) correctAnswerOverlay.style.display = 'none';
    if (correctAnswerTimeoutId) { // Clear any pending hide timeout
         clearTimeout(correctAnswerTimeoutId);
         correctAnswerTimeoutId = null;
    }

        // Display game over screen
        const gameOverScreen = document.getElementById('gameOverScreen');
        gameOverScreen.style.display = 'flex'; // Use flex for centering
        gameOverScreen.style.flexDirection = 'column';
        gameOverScreen.style.justifyContent = 'center';
        gameOverScreen.style.alignItems = 'center';

	     // --- START HIGH SCORE INTEGRATION ---
    gameOverScreen.innerHTML = '<h2>Game Over!</h2>'; // Clear previous content

    const finalScoreDisplay = document.createElement('p');
    finalScoreDisplay.style.fontSize = '24px';
    finalScoreDisplay.textContent = `Final Score: ${mathScore}`;
    gameOverScreen.appendChild(finalScoreDisplay);

    const highScoreContainer = document.createElement('div');
    highScoreContainer.id = 'highScoreListContainer'; // ID for display function
    highScoreContainer.style.marginTop = '20px';
    highScoreContainer.style.textAlign = 'left';
    highScoreContainer.innerHTML = '<p>Loading high scores...</p>'; // Placeholder
    gameOverScreen.appendChild(highScoreContainer);

    // Load existing scores
    const currentHighScores = await loadHighScoresFromFirebase();

    // Check if the current score is a high score
    if (isHighScore(mathScore, currentHighScores)) {
        console.log("New High Score!");
        finalScoreDisplay.textContent += " - New High Score!";

        // Create input form
        const form = document.createElement('div'); // Use div instead of form to prevent reload
        form.style.marginTop = '15px';
        form.innerHTML = `
            <label for="playerNameInput">Enter Name:</label>
            <input type="text" id="playerNameInput" maxlength="49" required>
            <button id="submitScoreBtn">Save Score</button>
        `;
        // Insert form before the high score list container
        gameOverScreen.insertBefore(form, highScoreContainer);

        const nameInput = document.getElementById('playerNameInput');
        const submitBtn = document.getElementById('submitScoreBtn');

         // Add focus to input shortly after display
         setTimeout(() => nameInput.focus(), 100);


        submitBtn.onclick = async () => { // Use async for saving
            const playerName = nameInput.value;
            if (playerName && playerName.trim().length > 0) {
                submitBtn.disabled = true; // Prevent double submit
                submitBtn.textContent = 'Saving...';
                const saved = await saveHighScoreToFirebase(playerName, mathScore);
                if (saved) {
                    // Remove form, refresh list
                    form.remove();
                    const updatedScores = await loadHighScoresFromFirebase();
                    displayHighScores(updatedScores, highScoreContainer.id);
                } else {
                    // Re-enable button on failure
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Save Score';
                    // Error message already shown by save function via alert
                }
            } else {
                 alert("Please enter a name.");
            }
        };

         // Also allow Enter key in input field to submit
         nameInput.onkeydown = (event) => {
            if (event.key === 'Enter') {
                submitBtn.click(); // Trigger button click
                event.preventDefault(); // Prevent default form submission
            }
         };

        // Display current scores below the input form
        displayHighScores(currentHighScores, highScoreContainer.id);

    } else {
         // Not a high score, just display the list
         console.log("Score not high enough for leaderboard.");
         displayHighScores(currentHighScores, highScoreContainer.id);
    }

     // Optional: Add a button or click handler to restart
     const restartButton = document.createElement('button');
     restartButton.textContent = 'Play Again?';
     restartButton.style.marginTop = '30px';
     restartButton.style.padding = '10px 20px';
     restartButton.onclick = () => { location.reload(); }; // Simple reload
     gameOverScreen.appendChild(restartButton);


    // --- END HIGH SCORE INTEGRATION ---

    }


    function gameLoop() {
      if (!gameRunning) return; // Exit loop if game is over

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background elements
      drawCastle();
		 updateWaveLogic(); // Handle wave progression and enemy spawning
         updateArmyCountDisplay(); // Update the display every frame
      // Update and Draw Units (player and enemy)
      [...units, ...enemies].forEach(u => {
        if (u.update) u.update(); // Make sure update exists before calling
        if (u.draw) u.draw();   // Make sure draw exists
      });
	    

      // Update and Draw Projectiles
      projectiles.forEach((p, index) => {
        if (p.update) p.update();
        if (p.draw) p.draw();
      });

      // Remove 'done' projectiles
      for (let i = projectiles.length - 1; i >= 0; i--) {
        if (projectiles[i].done) {
          projectiles.splice(i, 1);
        }
      }
	         // --- Draw Active Shockwaves (Orange/Red) ---
      // Drawing AFTER units ensures the effect isn't immediately covered
      ctx.save();
      units.forEach(unit => {
          // Check if it's a Mage AND its shockwave is active
          if (unit instanceof Mage && unit.shockwaveActive) {

              // --- START REPLACEMENT: Restore Dynamic Circle ---
              // Calculate animation progress (0 = start, 1 = end)
              const progress = 1.0 - (unit.shockwaveTimer / unit.shockwaveDuration);

              // Calculate current radius based on progress (linear expansion)
              const currentRadius = unit.shockwaveMaxRadius * progress;

              // Calculate opacity (fades out from 1 to 0)
              const opacity = 1.0 - progress;

              // Set drawing style (e.g., Orange/Red fading out)
              // Ensure opacity is not negative if timer logic is slightly off
              const safeOpacity = Math.max(0, opacity);
              ctx.strokeStyle = `rgba(255, 100, 0, ${safeOpacity})`; // Orange-Red, fades alpha

              // Make line thinner as it expands (optional)
              const currentLineWidth = Math.max(1, 4 * (1.0 - progress) + 1);
              ctx.lineWidth = currentLineWidth;

              // Draw the expanding circle
              ctx.beginPath();
              ctx.arc(unit.x, unit.y, currentRadius, 0, Math.PI * 2);
              // Only stroke if opacity is still significant to avoid drawing invisible lines
              if (safeOpacity > 0.05) {
                   ctx.stroke();
              }
              // --- END REPLACEMENT ---

              // Optional: Keep this log temporarily if you want to verify parameters
              // console.log(`DEBUG: Drawing shockwave indicator for Mage at (${unit.x.toFixed(0)}, ${unit.y.toFixed(0)}), Timer: ${unit.shockwaveTimer}`);
          }
      });
      ctx.restore();
      // --- End Draw Active Shockwaves ---

	 // --- START ADDITION: Draw Mana Charge Pulse ---
        ctx.save();
        units.forEach(unit => {
            // Draw ONLY if it's a Mage AND it's currently in the 'waiting for mana' state
            if (unit instanceof Mage && unit.isFleeingOOM) {
                // Calculate pulsing effect using sine wave based on the cycling timer
                // progress goes 0 -> 1 over the duration
                const progress = unit.manaChargeAnimTimer / unit.manaChargeAnimDuration;
                // angle goes 0 -> 2*PI
                const angle = progress * Math.PI * 2;
                // pulseFactor goes 0 -> 1 -> 0 using sine shifted -PI/2
                const pulseFactor = (Math.sin(angle - Math.PI / 2) + 1) / 2;

                // Calculate current radius based on pulse (e.g., radius * 0.5 up to maxRadius)
                const currentRadius = (unit.radius * 0.5) + (unit.manaChargeMaxRadius - unit.radius * 0.5) * pulseFactor;

                // Calculate current opacity based on pulse
                const currentOpacity = unit.manaChargeBaseOpacity * pulseFactor;

                // Set drawing style (Blue, pulsing opacity)
                ctx.fillStyle = `rgba(52, 152, 219, ${currentOpacity})`; // Blue color (adjust RGB as desired)

                // Draw the pulsing circle (filled, no stroke)
                ctx.beginPath();
                ctx.arc(unit.x, unit.y, currentRadius, 0, Math.PI * 2);
                // Only draw if slightly visible
                if (currentOpacity > 0.05 && currentRadius > 1) {
                    ctx.fill();
                }
            }
        });
        ctx.restore();
        // --- END ADDITION ---
	    
       // Check for castle destruction (redundant check, but safe)
       if (castle.hp <= 0) {
           gameOver();
       }

      // Request next frame
      requestAnimationFrame(gameLoop);
    } 
    updateScoreDisplay();
    askMathProblem();
     currentWave = 0; // Start before Wave 1
    waveState = 'INTERMISSION';
    waveTimer = INITIAL_INTERMISSION_DURATION; // Set initial pause before Wave 1 starts
    updateWaveStatusDisplay(`Get Ready! Wave 1 starting soon...`);
    gameLoop(); // Start the main game loop
    
    window.addEventListener('keydown', handleKeyPress);
    const answerInput = document.getElementById('answerInput'); // Get reference once if possible outside loop

if (answerInput) { // Make sure the element exists before adding listener
  answerInput.addEventListener('input', function(event) {
    // Get the current value
    const value = event.target.value;

    // Remove any 'e' or 'E' characters using regex (global, case-insensitive)
    // Also remove '+' as some browsers allow it in number fields
    const sanitizedValue = value.replace(/[eE+]/g, '');

    // If the sanitized value is different from the original value, update the input
    if (sanitizedValue !== value) {
        event.target.value = sanitizedValue;
    }
  });
} else {
    console.error("Could not find answerInput to attach input listener!");
}

updateUpgradeButtonDisplay();
updateArmyCountDisplay(); // Set initial army count display

  </script>
</body>
</html>
