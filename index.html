<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MathDefend</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { background: #f0f0f0; display: block; margin: 0 auto; border: 1px solid #ccc; }
    #controls { text-align: center; margin: 10px; }
     #controls button { /* Target buttons specifically within the controls div */
        margin: 0 5px;
        padding: 8px 15px; /* Add padding: 8px top/bottom, 15px left/right */
        cursor: pointer; /* Ensure cursor indicates clickability */
        font-size: 14px; /* Optional: Adjust font size if needed */
        border: 1px solid #aaa; /* Optional: Add a subtle border */
        border-radius: 4px; /* Optional: Slightly rounded corners */
        background-color: #e7e7e7; /* Optional: Default background */
    }
    /* Style the upgrade button slightly differently if desired */
    #upgradeCapButton {
        background-color: #d4af37; /* Keep its gold color */
        color: black;
        border-color: #b89b32; /* Darker gold border */
    }
    /* Optional: Add hover/active states for better feedback */
    #controls button:hover {
        background-color: #dcdcdc;
    }
    #upgradeCapButton:hover {
         background-color: #c8a432;
    }
     #controls button:active {
         background-color: #c0c0c0;
         transform: translateY(1px); /* Slight press effect */
     }
     #upgradeCapButton:active {
         background-color: #b89b32;
         transform: translateY(1px);
     }
    #scoreDisplay { text-align: center; margin: 10px; font-size: 16px; }
    #mathProblem { text-align: center; margin: 10px; font-size: 18px; }
    #gameOverScreen {
      display: none; /* Keep this */
      flex-direction: column; /* Stack items vertically */
      justify-content: center; /* Center vertically */
      align-items: center; /* Center horizontally */
      position: fixed; /* Position relative to viewport */
      top: 0;          /* Align to top */
      left: 0;         /* Align to left */
      width: 100vw;    /* Full viewport width */
      height: 100vh;   /* Full viewport height */
      background-color: rgba(0, 0, 0, 0.85); /* Slightly darker? */
      color: white;
      font-size: 24px; /* Adjust base font size if needed */
      text-align: center; /* Center text within elements */
      /* padding-top: 0; */ /* Remove fixed padding-top if you had it */
      padding: 20px; /* Add some general padding */
      z-index: 10;
      box-sizing: border-box; /* Include padding in width/height */
      overflow-y: auto; /* Add scrollbar ONLY if content overflows */
    }
    /* Adjust heading/paragraph margins if needed */
    #gameOverScreen h2 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 36px;
    }
     #gameOverScreen p {
        margin: 10px 0;
     }
     #highScoreListContainer {
         max-width: 400px; /* Limit width of score list */
         width: 90%;
         margin-top: 20px;
         text-align: left; /* Align list text left */
         border: 1px solid #555; /* Optional border */
         padding: 15px;
         background-color: rgba(20, 20, 20, 0.5); /* Slight background */
         border-radius: 5px;
     }
      #highScoreListContainer h3 {
          margin-top: 0;
          text-align: center; /* Center the "High Scores:" heading */
      }
      #highScoreListContainer ol {
          padding-left: 25px; /* Indent numbers slightly */
          margin-bottom: 0;
      }
      #highScoreListContainer li {
          margin-bottom: 5px; /* Space between entries */
      }
  </style>
   <!-- Firebase v9+ Modular SDK -->
    <!-- Core App Module (You already have this) -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js"; // Use your actual version if different

      // Paste your actual firebaseConfig object here!
const firebaseConfig = {
    apiKey: "AIzaSyCx_SQ23AvzsOj1btO9YqzLQQ-C9xD07_E",
    authDomain: "math-game-leaderboard-e6970.firebaseapp.com",
    projectId: "math-game-leaderboard-e6970",
    storageBucket: "math-game-leaderboard-e6970.firebasestorage.app",
    messagingSenderId: "291357117755",
    appId: "1:291357117755:web:e1f49d75b614ff3b227b1e"
  };

  // Initialize Firebase
      const app = initializeApp(firebaseConfig);

      // Make the initialized app available globally or pass it down
      // For simplicity here, we can make it accessible via a global scope if needed,
      // but ideally you'd import necessary functions directly in your main script.
      // Let's make it accessible for now:
      window.firebaseApp = app;
       </script>

    <!-- Firestore Module -->
    <script type="module" src="https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js"></script>
	    
</head>
<body>
  <div id="controls">
    <button onclick="spawnUnit('melee')">Spawn [M]elee (Cost: 10)</button>
    <button onclick="spawnUnit('archer')">Spawn [A]rcher (Cost: 15)</button>
    <button onclick="spawnUnit('mage')">Spawn Ma[G]e (Cost: 50)</button>
    <button id="upgradeCapButton" onclick="upgradeArmyCap()" style="margin-left: 20px; background-color: #d4af37; color: black;">
      [U]pgrade Cap (15 -> 20) (Cost: 75)
    </button>
  </div>
  <div id="scoreDisplay">ðŸª™ Gold: <span id="score">0</span>     ðŸ“ˆ Score: <span id="mathScore">0</span></div>
	 <div id="waveStatus" style="text-align: center; margin: 5px; font-size: 18px; font-weight: bold; color: #333;">Game Starting...</div>
       <div id="armyCountDisplay" style="text-align: center; margin: 5px; font-size: 16px; color: #555;">
    Units: 0 / 15
  </div>
  <div id="mathProblem"></div>
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <div id="gameOverScreen">Game Over!<br/><span>Final Score: 0</span></div>

  <script type="module">	
     // --- START FIREBASE V9+ SETUP ---
    // Access the initialized app from the global scope (or import if using modules for game script too)
    const app = window.firebaseApp; // Get the app initialized in the head

   // Import necessary Firestore functions DIRECTLY from the SDK URL
        import {
            getFirestore,
            collection,
            getDocs,
            query,
            orderBy,
            limit,
            addDoc,
            serverTimestamp // Make sure you import serverTimestamp specifically
        } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore.js"; // Use your actual version


    // Get a Firestore instance
    const db = getFirestore(app); // Pass the initialized app
    const highScoresCollectionRef = collection(db, 'highscores'); // Reference to the collection
    const MAX_HIGH_SCORES = 10;
    // --- END FIREBASE V9+ SETUP ---
	  
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const SAFE_MARGIN = 40; // Keep units away from edges initially
    const SEPARATION_DISTANCE = 25; // Min distance units try to maintain
    const SEPARATION_STRENGTH = 0.5; // How strongly they push apart
    const FLASH_DURATION = 10; // Duration of damage flash effect in frames
    const WAVE_CLEAR_BASE_GOLD = 25;    // Base gold reward for clearing a wave
    const WAVE_CLEAR_GOLD_PER_WAVE = 5; // Additional gold per wave number
    
    const BASE_ARMY_CAP = 10;                  // Starting maximum number of player units
    const ARMY_CAP_INCREASE_PER_UPGRADE = 5;   // How many slots each upgrade adds
    const BASE_ARMY_CAP_UPGRADE_COST = 75;     // Cost of the *first* upgrade
    const ARMY_CAP_UPGRADE_COST_SCALING = 1.8; // Cost multiplier for subsequent upgrades (e.g., 1.8x)

    let currentArmyCap = BASE_ARMY_CAP;         // Player's current cap
    let armyCapUpgradeLevel = 0;                // How many times the cap has been upgraded

    const units = [];
    const enemies = [];
    const projectiles = [];
    let score = 50; // Starting gold
    let mathScore = 0;
    let currentAnswer = 0;
    let currentOperands = [0, 0];
    let currentOperator = '+';
    let gameRunning = true; // Flag to stop updates when game over
    let currentWave = 0;
    let waveState = 'INTERMISSION'; // Possible states: 'INTERMISSION', 'SPAWNING'
    let waveTimer = 0; // General timer for current phase (frames)
    let spawnTimer = 0; // Timer between spawns within a wave (frames)

    let enemiesToSpawnThisWave = 0;
    let enemiesSpawnedThisWave = 0;
    let waveSpawnInterval = 0; // Frames between spawns for the current wave

    const BASE_INTERMISSION_DURATION = 25 * 60; // 15 seconds in frames (assuming 60fps)
    const INITIAL_INTERMISSION_DURATION = 8 * 60; // Shorter pause before Wave 1
    const BASE_ENEMY_COUNT = 5;
    const ENEMY_COUNT_INCREASE_PER_WAVE = 2;
    const BASE_SPAWN_INTERVAL = 200; // Frames (2 seconds)
    const SPAWN_INTERVAL_DECREASE_PER_WAVE = 10; // Frames
    const MIN_SPAWN_INTERVAL = 35; // Minimum frames (0.5 seconds)
    const sndSpawnSuccess = new Audio('sounds/cash.mp3');
    const sndNoGold = new Audio('sounds/no-money.mp3');
    const sndEnemySpawn = new Audio('sounds/attack.mp3');
    const sndArcherFire = new Audio('sounds/shoot.mp3');
    const sndMeleeHit = new Audio('sounds/sword.mp3');
    const sndArrowHit = new Audio('sounds/shoot-hit.mp3');
    const sndMageBounce = new Audio('sounds/push.mp3');
    const sndHealPulse = new Audio('sounds/heal.mp3'); // Keep this one short!
    const sndMathCorrect = new Audio('sounds/correct-answer-sound.mp3');
    const sndMathIncorrect = new Audio('sounds/wrong-answer-sound.mp3');
    const sndWaveStart = new Audio('sounds/start-game.mp3');
    const sndGameOver = new Audio('sounds/game-over.mp3');
    // Optional: Adjust volume (0.0 to 1.0) if needed
    sndSpawnSuccess.volume = 1;
    sndNoGold.volume = 1;
    sndEnemySpawn.volume = 1;
    sndArcherFire.volume = 0.3;
    sndMeleeHit.volume = 0.5;
    sndArrowHit.volume = 0.3;
    sndMageBounce.volume = 0.7;
    sndHealPulse.volume = 0.7;
    sndMathCorrect.volume = 1;
    sndMathIncorrect.volume = 1;
    sndWaveStart.volume = 1;
    sndGameOver.volume = 1;
    const castle = {
      x: canvas.width / 2,
      y: canvas.height - 60, // Center Y of the castle structure base
      width: 120,
      height: 100,
      maxHp: 30000,
      hp: 30000
    };

	    // --- START ADDITION: Army Count Display Function ---
    function updateArmyCountDisplay() {
        const displayElement = document.getElementById('armyCountDisplay');
        if (displayElement) {
            displayElement.innerText = `Units: ${units.length} / ${currentArmyCap}`;

            // Optional: Change color if at cap
            if (units.length >= currentArmyCap) {
                displayElement.style.color = 'darkred'; // Indicate cap reached
                displayElement.style.fontWeight = 'bold';
            } else {
                displayElement.style.color = '#555'; // Default color
                displayElement.style.fontWeight = 'normal';
            }
        }
    }
    // --- END ADDITION ---


   function playSound(sound) {
        // Check if sound object is valid
        if (sound && typeof sound.play === 'function') {
            // Reset playback to the start - allows rapid re-triggering
            sound.currentTime = 0;
            sound.play().catch(error => {
                // Autoplay restrictions might prevent sound initially
                // Often resolves after first user interaction (click/key)
                // console.warn("Sound playback failed:", error);
            });
        } else {
            console.warn("Attempted to play invalid sound object:", sound);
        }
    }
	  
   function updateScoreDisplay() {
     document.getElementById('score').innerText = score;
     document.getElementById('mathScore').innerText = mathScore;
   }


    function drawCastle() {
      const { x, y, width, height, hp, maxHp } = castle;
      const left = x - width / 2;
      const top = y - height / 2;

      // Draw structure
      ctx.fillStyle = '#5a4d41'; // Brownish color
      ctx.fillRect(left, top, width, height); // Main block

      ctx.fillStyle = '#8b7e75'; // Lighter stone color for details
      // Draw towers (simplified)
      const towerWidth = width * 0.2;
      const towerHeight = height * 1.2;
      ctx.fillRect(left - towerWidth * 0.1, top - (towerHeight-height), towerWidth, towerHeight); // Left tower
      ctx.fillRect(left + width - towerWidth*0.9, top - (towerHeight-height), towerWidth, towerHeight); // Right tower

      // Draw battlements (simplified crenellations)
      const battlementHeight = 15;
      const battlementWidth = 15;
      const numBattlements = Math.floor(width / (battlementWidth * 1.5));
      ctx.fillStyle = '#5a4d41';
      for(let i=0; i < numBattlements; i++) {
          ctx.fillRect(left + i * (battlementWidth * 1.5) + battlementWidth*0.25, top - battlementHeight, battlementWidth, battlementHeight);
      }

      // Health bar (above castle)
      const healthRatio = Math.max(0, hp / maxHp); // Ensure ratio doesn't go below 0
      const barWidth = 100;
      const barHeight = 10;
      const barX = x - barWidth / 2;
      const barY = top - 30; // Position the health bar above the castle

      ctx.save();
      ctx.fillStyle = '#333'; // Background of bar
      ctx.fillRect(barX, barY, barWidth, barHeight);
      ctx.fillStyle = healthRatio > 0.5 ? 'lime' : healthRatio > 0.2 ? 'yellow' : 'red'; // Color changes with health
      ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
      ctx.strokeStyle = '#222'; // Border for clarity
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      ctx.restore();
    }


        function askMathProblem() {
      // 1. Add '/' to the list of possible operators
      const ops = ['+', '-', '*', '/'];
      const op = ops[Math.floor(Math.random() * ops.length)];

      let a, b;

      // 2. Generate numbers based on the chosen operator
      if (op === '/') {
          // Generate division problems: a / b = c
          // Ensure b > 1 (divisor is 2-10)
          // Ensure c > 1 (result is 2-10)
          let divisor = Math.floor(Math.random() * 9) + 2; // b = Divisor (2 to 10) - Avoids 1
          let result = Math.floor(Math.random() * 9) + 2;  // c = Result (2 to 10)
          a = divisor * result; // Calculate a = b * c
          b = divisor;          // Assign divisor to b
      } else {
          // Generate numbers for +, -, * as before
          a = Math.floor(Math.random() * 10) + 1;
          b = Math.floor(Math.random() * 10) + 1;

          // Ensure subtraction is not negative
          if (op === '-' && a < b) {
              [a, b] = [b, a];
          }
      }

      currentOperands = [a, b];
      currentOperator = op;

      // 3. Modify 'isHard' logic: Mark ALL division as hard for now
      const isHard =
           // Multiplication (unchanged)
           (op === '*' && (a > 5 || b > 5) && a !== 1 && b !== 1 && a !== 10 && b !== 10) ||
           // Addition (unchanged)
           (op === '+' && a + b > 15) ||
           // Subtraction (unchanged)
           (op === '-' && a > 15) ||
           // --- MODIFICATION: Division is always hard ---
           (op === '/');
           // --- END MODIFICATION ---

      // 4. Construct problem string and calculate answer
      const problemStr = `${a} ${op} ${b}`;
      currentAnswer = eval(problemStr);

      // --- Display logic remains the same ---
      const container = document.getElementById('mathProblem');
      container.innerHTML = `<form id="mathForm">
        <span>${problemStr} = ?</span>
        ${isHard ? '<span style="color:gold; font-weight:bold; margin-left: 10px;">ðŸ’° Bonus!</span>' : ''}
        <input type="number" id="answerInput" required style="margin-left: 10px; width: 50px;">
        <button type="submit">Submit</button>
      </form>`;

      document.getElementById('mathForm').addEventListener('submit', submitAnswer);
      setTimeout(() => {
        const input = document.getElementById('answerInput');
        if (input) input.focus();
       }, 50);
    }


    function submitAnswer(event) {
      if (event) event.preventDefault(); // Prevent form reload
      if (!gameRunning) return; // Don't process answers if game over

      const input = document.getElementById('answerInput');
      const value = parseInt(input.value, 10);

      if (!isNaN(value) && value === currentAnswer) {
        // Correct answer
        let baseGold = 5;
        let operatorBonus = 0;
        if (currentOperator === '*') operatorBonus = 10;
        else if (currentOperator === '-') operatorBonus = 2;

        let operandBonus = 0;
        if (currentOperands[0] > 8 || currentOperands[1] > 8) operandBonus += 3;
        if (currentOperands[0] + currentOperands[1] > 15) operandBonus += 3;

        let totalGold = baseGold + operatorBonus + operandBonus;

        score += totalGold;
        mathScore += totalGold; // Use the same value for simplicity, or calculate differently

        updateScoreDisplay();
	playSound(sndMathCorrect);
        // Optional: Visual feedback for correct answer
        document.getElementById('mathProblem').style.backgroundColor = 'lightgreen';
        setTimeout(() => { document.getElementById('mathProblem').style.backgroundColor = ''; }, 200);

      } else {
         // Optional: Visual feedback for incorrect answer
	playSound(sndMathIncorrect);
        document.getElementById('mathProblem').style.backgroundColor = 'lightcoral';
        setTimeout(() => { document.getElementById('mathProblem').style.backgroundColor = ''; }, 200);
      }

      // Ask new question regardless of correctness
      input.value = ""; // Clear input
      askMathProblem();
    }

    // --- Unit Classes ---

    class Unit {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'melee', 'archer', 'mage', 'enemy'
        this.radius = (type === 'enemy' ? 12 : 10); // Enemy slightly bigger?
        this.maxHp = (type === 'enemy' ? 80 : 100); // Enemies maybe slightly weaker?
        this.hp = this.maxHp;
        this.target = null;
        this.cooldown = 0; // For attacks/abilities
	

        // Type-specific properties
        switch (type) {
          case 'melee':
            this.color = 'blue';
            this.speed = 1.5;
            this.range = 30; // Melee range
            this.attackDamage = 1;
            this.attackCooldown = 30; // frames (0.5s at 60fps)
            break;
          case 'archer':
            this.color = 'purple';
            this.speed = 1.3;
            this.range = 150;
            this.projectileDamage = 3;
            this.attackCooldown = 60; // frames (1s at 60fps)
            break;
          case 'mage': // Base properties if Mage isn't used, overridden by Mage class
            this.color = 'cyan';
            this.speed = 1.2;
            this.range = 100;
            this.attackDamage = 0; // Mages don't attack directly in this setup
            this.attackCooldown = 1000; // Effectively no attack
            break;
          case 'enemy':
            this.color = 'darkred';
            this.speed = 1.0 + Math.random() * 0.4; // Slight speed variation
            this.range = 30; // Enemy melee range
            this.attackDamage = 2;
             this.attackCooldown = 30;
            this.castleDamage = 0.2; // Damage per frame to castle
	    this.bounceVelX = 0; // Current velocity component from bounce X
        this.bounceVelY = 0; // Current velocity component from bounce Y
        this.bounceDecay = 0.95; // Velocity retained each frame (e.g., 0.92 = loses 8% per frame)
            break;
          default:
             this.color = 'grey';
             this.speed = 1;
             this.range = 10;
             this.attackDamage = 0.5;
             this.attackCooldown = 60;
        }
      }

      draw() {
        // Body
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.strokeStyle = 'black'; // Outline
        ctx.lineWidth = 1;
        ctx.stroke();

        // Health bar
        const barWidth = this.radius * 2.5;
        const barHeight = 4;
        const barX = this.x - barWidth / 2;
        const barY = this.y - this.radius - 8; // Position above unit
        const healthRatio = Math.max(0, this.hp / this.maxHp);

        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        ctx.fillStyle = healthRatio > 0.5 ? 'lime' : healthRatio > 0.2 ? 'yellow' : 'red';
        ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
      }

          update() {
        // --- Initial Checks ---
        if (this.hp <= 0) {
            this.remove();
            return;
        }
        if (this.cooldown > 0) {
            this.cooldown--;
        }

        // --- Mage Specific State Updates (Ran every frame for Mages) ---
        if (this.type === 'mage') {
            if (this.currentMana < this.maxMana) {
                this.currentMana = Math.min(this.maxMana, this.currentMana + this.manaRegenRate);
            }
            if (this.bounceCooldown > 0) { this.bounceCooldown--; }
            if (this.shockwaveActive) {
                this.shockwaveTimer--;
                if (this.shockwaveTimer <= 0) { this.shockwaveActive = false; }
            }
        }

        // --- Determine Movement Intention (targetDX/DY) ---
        let targetDX = 0;
        let targetDY = 0;
        let separationDX = 0;
        let separationDY = 0;

        // --- Find Target (Relevant for most types) ---
        // Find relevant target first
        if (this.type === 'enemy') {
            this.target = this.findNearest(units); // Target player units
        } else if (this.type === 'melee' || this.type === 'archer') {
            this.target = this.findNearest(enemies); // Target enemies
        }
        // Mage target is handled within its own logic block


        // --- Calculate Target/Goal Movement Based on Type ---

        if (this.type === 'enemy') {
            // --- Enemy Logic ---
            const castleDist = this.distanceTo(castle);
            if (this.target) {
                const dist = this.distanceTo(this.target);
                if (dist <= this.range) {
                    this.attack(this.target);
                    targetDX = 0; targetDY = 0; // Stop moving when attacking
                } else {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const targetDist = Math.hypot(dx, dy);
                    if (targetDist > 0) { targetDX = (dx / targetDist); targetDY = (dy / targetDist); }
                }
            } else if (castleDist <= this.range + castle.width / 2) {
                if (castle.hp > 0) {
                    castle.hp -= this.castleDamage;
                    if (castle.hp <= 0) { gameOver(); return; }
                }
                targetDX = 0; targetDY = 0; // Stop moving
            } else {
                const dx = castle.x - this.x;
                const dy = (castle.y - castle.height / 2 + this.radius) - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) { targetDX = (dx / dist); targetDY = (dy / dist); }
            }
        // --- CORRECTED STRUCTURE FOR PLAYER UNITS ---
        } else if (this.type === 'melee') {
            // --- Melee Logic ---
            if (this.target) {
                const dist = this.distanceTo(this.target);
                if (dist <= this.range) {
                    this.attack(this.target);
                    targetDX = 0; targetDY = 0;
                } else {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const targetDist = Math.hypot(dx, dy);
                    if (targetDist > 0) { targetDX = (dx / targetDist); targetDY = (dy / targetDist); }
                }
            } else {
                targetDX = 0; targetDY = 0; // No target, stand still
            }
        } else if (this.type === 'archer') {
            // --- Archer Logic ---
             if (this.target) {
                 const dist = this.distanceTo(this.target);
                 const idealDist = this.range * 0.8;
                 if (dist < idealDist) {
                     const dx = this.x - this.target.x;
                     const dy = this.y - this.target.y;
                     const fleeDist = Math.hypot(dx, dy);
                     if (fleeDist > 0) { targetDX = (dx / fleeDist); targetDY = (dy / fleeDist); }
                     if (dist <= this.range) this.shoot(this.target);
                 } else if (dist <= this.range) {
                     this.shoot(this.target);
                     targetDX = 0; targetDY = 0;
                 } else {
                     const dx = this.target.x - this.x;
                     const dy = this.target.y - this.y;
                     const targetDist = Math.hypot(dx, dy);
                     if (targetDist > 0) { targetDX = (dx / targetDist); targetDY = (dy / targetDist); }
                 }
            } else {
                targetDX = 0; targetDY = 0; // No target, stand still
            }
                   } else if (this.type === 'mage') {
            // --- Mage Logic ---
            // NOTE: Core state updates (mana regen, cooldowns, shockwave timer) happen at the start of Unit.update

            // --- STATE TRANSITION: Should we ENTER the 'Waiting for Full Mana' state? ---
            // Check if mana just dropped below threshold AND we are not already waiting
            if (!this.isFleeingOOM && this.currentMana < this.lowManaThreshold) {
                 this.isFleeingOOM = true; // Enter the waiting state
                 this.target = null; // Clear offensive target
                 // console.log(`Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}) ENTERED Waiting State (Low Mana).`);
            }

            // --- Primary State Check: Are we currently WAITING FOR FULL MANA? ---
            if (this.isFleeingOOM) {
                // --- ACTION: Waiting for Mana ---

                // A. Check if mana is fully restored to EXIT the state
                if (this.currentMana >= this.maxMana) {
                    this.isFleeingOOM = false; // Exit waiting state
                    // console.log(`Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}) EXITED Waiting State (Mana Full).`);
                    targetDX = 0; targetDY = 0; // Stop moving for this frame
                    // Normal logic will apply next frame
                } else {
		    this.manaChargeAnimTimer = (this.manaChargeAnimTimer + 1) % this.manaChargeAnimDuration;
                    // B. STILL Waiting: Mana is not full. Determine movement based on threats.
                    let fleeTarget = null;
                    let closestEnemyDist = Infinity;
                    const fleeCheckRadius = 120;

                    for (const enemy of enemies) { // Find nearest threat
                        if (enemy.hp <= 0) continue;
                        const d = this.distanceTo(enemy);
                        if (d < fleeCheckRadius && d < closestEnemyDist) {
                            closestEnemyDist = d;
                            fleeTarget = enemy;
                        }
                    }

                    // Set movement: Flee if threat found, otherwise stand still
                    if (fleeTarget) {
                        const dx = this.x - fleeTarget.x;
                        const dy = this.y - fleeTarget.y;
                        const fleeDist = Math.hypot(dx, dy);
                        if (fleeDist > 0) { targetDX = (dx / fleeDist); targetDY = (dy / fleeDist); }
                        else { targetDX = (Math.random() - 0.5); targetDY = (Math.random() - 0.5); }
                         // console.log(`Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}) is WAITING and FLEEING.`);
                    } else {
                        targetDX = 0; // Stand still if waiting and no threat
                        targetDY = 0;
                        // console.log(`Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}) is WAITING and IDLE.`);
                    }
                    // CRITICAL: No healing/bouncing/move-to-heal while in this state.
                }

            } else {
                 // --- ACTION: Normal Operation (Not Waiting for Full Mana) ---
                 // We only reach here if isFleeingOOM is false.

                // Find target for bounce check
                this.target = this.findNearest(enemies);

                // Attempt abilities
                this.healNearbyUnits(); // Checks mana internally
                if (this.bounceCooldown <= 0) {
                    this.triggerBounceOff(); // Checks mana internally via performBounce
                }

                // Determine movement goal if not currently being bounced
                const isBouncing = (Math.abs(this.bounceVelX) > 0.01 || Math.abs(this.bounceVelY) > 0.01);
                if (!isBouncing) {
                    const moveGoal = this.findHealingTargetMovement();
                    if (moveGoal) {
                        targetDX = moveGoal.dx;
                        targetDY = moveGoal.dy;
                    }
                }
                // Else: Bouncing handles movement, or stand still if no heal target
            } // End of main state check (isFleeingOOM or not)
        } // --- End Mage Logic Block ---
        // --- END CORRECTED STRUCTURE ---

        // --- Calculate Separation Force ---
        // (This part remains the same)
        const nearbyUnits = (this.type === 'enemy' ? [...units, ...enemies] : [...units, ...enemies]);
        for (const other of nearbyUnits) {
            if (other === this || other.hp <= 0) continue;
            const dist = this.distanceTo(other);
            if (dist > 0 && dist < SEPARATION_DISTANCE) {
                const pushX = this.x - other.x;
                const pushY = this.y - other.y;
                const strength = SEPARATION_STRENGTH * (1 - dist / SEPARATION_DISTANCE);
                separationDX += (pushX / dist) * strength;
                separationDY += (pushY / dist) * strength;
            }
        }

        // --- Apply Movement Logic ---
        // (This part remains the same - handles bounce vs normal movement)
        let isBouncing = (Math.abs(this.bounceVelX) > 0.01 || Math.abs(this.bounceVelY) > 0.01);
        let moveX = 0;
        let moveY = 0;

        if (isBouncing) {
            this.bounceVelX *= this.bounceDecay;
            this.bounceVelY *= this.bounceDecay;
            moveX = this.bounceVelX;
            moveY = this.bounceVelY;
            if (Math.hypot(this.bounceVelX, this.bounceVelY) < 0.1) {
                this.bounceVelX = 0;
                this.bounceVelY = 0;
            }
        }

        if (!isBouncing) {
            const normalDX = targetDX + separationDX;
            const normalDY = targetDY + separationDY;
            const normalDist = Math.hypot(normalDX, normalDY);
            if (normalDist > 0) {
                moveX += (normalDX / normalDist) * this.speed;
                moveY += (normalDY / normalDist) * this.speed;
            }
        }

        this.x += moveX;
        this.y += moveY;

        // --- Post-Movement Actions ---
        this.enforceBounds();

    } // End of update() method - Ensure this brace matches the 'update() {' at the start
	    
      findNearest(targets) {
        let minDist = Infinity;
        let nearest = null;
        for (const t of targets) {
            if (t.hp <= 0) continue; // Ignore dead targets
            const d = this.distanceTo(t);
            if (d < minDist) {
                minDist = d;
                nearest = t;
            }
        }
        return nearest;
      }

      distanceTo(other) {
          let otherX, otherY;
          if (other === castle) {
              // Find closest point on castle rectangle to the unit's center
              const left = castle.x - castle.width / 2;
              const right = castle.x + castle.width / 2;
              const top = castle.y - castle.height / 2;
              const bottom = castle.y + castle.height / 2;
              otherX = Math.max(left, Math.min(this.x, right));
              otherY = Math.max(top, Math.min(this.y, bottom));
          } else {
               if (!other || typeof other.x === 'undefined' || typeof other.y === 'undefined') {
                   // console.warn("Invalid target in distanceTo:", other);
                   return Infinity; // Avoid errors with invalid targets
               }
              otherX = other.x;
              otherY = other.y;
          }
          const dx = this.x - otherX;
          const dy = this.y - otherY;
          return Math.hypot(dx, dy);
      }

           attack(target) {
        // Check if attack is possible (cooldown ready, valid target with HP)
        if (this.cooldown <= 0 && target && target.hp > 0) {

            // --- START FIX: Ensure oldHp is defined here ---
            const oldHp = target.hp; // Store target's HP *before* dealing damage
            // --- END FIX ---

            // Apply damage
            target.hp -= this.attackDamage;

            // Trigger damage flash
            target.damageFlashTimer = FLASH_DURATION;

            // Reset attacker's cooldown
            this.cooldown = this.attackCooldown;

            // Play hit sound only if damage was actually dealt (target hp decreased)
            // Now 'oldHp' is guaranteed to be defined in this scope
            if (target.hp < oldHp) {
                 playSound(sndMeleeHit);
            }

            // Check if the target died from this attack
             if (target.hp <= 0) {
                 this.target = null; // Clear attacker's target reference if target died
             }
        }
        // Note: No 'else' block needed here unless you want specific logging for failed attacks
      }

      shoot(target) {
        if (this.cooldown <= 0 && target && target.hp > 0) {
          projectiles.push(new Projectile(this.x, this.y, target, this.projectileDamage, this)); // Pass damage and owner
          this.cooldown = this.attackCooldown;
	  playSound(sndArcherFire);
        }
      }

      enforceBounds() {
        // Keep units fully within the canvas, respecting SAFE_MARGIN
        // Use SAFE_MARGIN directly as the minimum boundary
        const minX = SAFE_MARGIN;
        const minY = SAFE_MARGIN;
        const maxX = canvas.width - SAFE_MARGIN;
        const maxY = canvas.height - SAFE_MARGIN;

        // Clamp the unit's CENTER position
        this.x = Math.max(minX, Math.min(this.x, maxX));
        this.y = Math.max(minY, Math.min(this.y, maxY));

        // Note: If a unit is pushed exactly to the margin, its edge
        // might still slightly overlap if radius > SAFE_MARGIN, but
        // its center will be kept within the safe zone.
        // For health bars always visible, ensure SAFE_MARGIN is large enough
        // (e.g., > unit radius + health bar height + buffer).
        // Current SAFE_MARGIN = 40 should be sufficient.
      }

      remove() {
        const list = (this.type === 'enemy' ? enemies : units);
        const idx = list.indexOf(this);
        if (idx !== -1) list.splice(idx, 1);
      }

      // Placeholder methods for Mage - will be overridden but prevent errors if called on base Unit
      updateMageSpecifics() { }
      findHealingTargetMovement() { return null; }

    } // End of Unit class

    // --- Mage Class ---
    class Mage extends Unit {
      constructor(x, y) {
        super(x, y, 'mage'); // Call base class constructor
        // Override or set Mage-specific properties
        this.color = '#2ecc71'; // Emerald green
        this.speed = 1.1;
        this.range = 120; // Range for abilities, not direct attack
        this.maxHp = 50; // Mages might be slightly squishier
        this.hp = this.maxHp;
	      
        this.isFleeingOOM = false; // True if currently fleeing due to low mana
        this.healRate = 0.16; // HP per frame
        this.healRange = 40;
        this.bounceCooldownMax = 500; // 360 value is 3 seconds at 60fps
        this.bounceCooldown = 0;
        this.bounceTriggerRange = 70; // Enemies within this range can trigger the bounce
        this.bounceEffectRange = 200; // Enemies within this range are affected when bounce triggers
        this.bounceForce = 150; // How far enemies are pushed
	this.bounceInitialSpeed = 9; // Adjust this value to control initial push speed

	this.shockwaveActive = false;
        this.shockwaveTimer = 0; // Counts down animation frames
        this.shockwaveDuration = 30; // Duration in frames (e.g., 0.5 seconds at 60fps)
        this.shockwaveMaxRadius = this.bounceEffectRange; // Expand out to the effect range

	this.manaChargeAnimTimer = 0; // Timer cycles continuously for pulsing effect
        this.manaChargeAnimDuration = 60; // Duration of one pulse cycle in frames (e.g., 1 second)
        this.manaChargeMaxRadius = this.radius * 1.8; // Max size of the blue pulse (smaller than bounce)
        this.manaChargeBaseOpacity = 0.5; // Base opacity for the blue pulse

	this.maxMana = 100;
        this.currentMana = this.maxMana; // Start full
        this.manaRegenRate = 0.15; // Mana per frame (e.g., 0.15 * 60 = 9 mana/sec)

        this.bounceManaCost = 35; // Cost to perform bounce
        this.healManaCost = 0.8; // Cost per successful heal tick applied
        this.lowManaThreshold = this.healManaCost; // Flee if mana is below this
      }

      // Called BY the base Unit.update() method specifically for mages
            // Called BY the base Unit.update() method specifically for mages
        updateMageSpecifics() {
              // --- START MODIFICATION: Add Logging ---
            // Manage the shockwave animation timer if it's active
            if (this.shockwaveActive) {
                // --- DETAILED LOGGING ---
                console.log(`Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}): updateMageSpecifics - shockwave IS active. Timer BEFORE decrement: ${this.shockwaveTimer}`);
                // --- END DETAILED LOGGING ---

                this.shockwaveTimer--; // Decrement the timer each frame

                if (this.shockwaveTimer <= 0) {
                    // --- DETAILED LOGGING ---
                    console.log(`%cMage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}): updateMageSpecifics - Timer reached 0. Setting shockwaveActive to false.`, "color: red;");
                    // --- END DETAILED LOGGING ---
                    this.shockwaveActive = false; // Deactivate the animation when timer runs out
                }
            }
            // --- END MODIFICATION ---
	    // --- START ADDITION: Mana Regeneration ---
            if (this.currentMana < this.maxMana) {
                 this.currentMana = Math.min(this.maxMana, this.currentMana + this.manaRegenRate);
            }
            // --- END ADDITION ---
            // Existing Mage logic (Healing and Bounce Cooldown)
            this.healNearbyUnits();

            if (this.bounceCooldown <= 0) {
                this.triggerBounceOff(); // Check if bounce should be triggered
            } else {
                this.bounceCooldown--; // Count down bounce ability cooldown
            }
        }

            // Provides movement direction towards the "best" target needing healing.
        // Best is determined by a score combining missing health and proximity.
        findHealingTargetMovement() {
            let bestTargetOverall = null;
            let highestScoreOverall = -1;

            // Find the allied unit (not self) with the highest score globally
            for (const unit of units) {
                // Skip self & units at full health
                if (unit === this || unit.hp >= unit.maxHp) continue;

                const dist = this.distanceTo(unit);
                // Add small amount to distance to prevent division by zero
                const distanceFactor = Math.max(dist, 1.0);
                const missingHp = unit.maxHp - unit.hp;
                const score = missingHp / distanceFactor;

                if (score > highestScoreOverall) {
                    highestScoreOverall = score;
                    bestTargetOverall = unit;
                }
            }

            // If a best target was found anywhere...
            if (bestTargetOverall) {
                const distToBest = this.distanceTo(bestTargetOverall);

                // Move towards it only if it's not already very close (outside ~70% heal range)
                if (distToBest > this.healRange * 0.7) {
                     const dx = bestTargetOverall.x - this.x;
                     const dy = bestTargetOverall.y - this.y;
                     // distToBest is already calculated, use it for normalization
                     if (distToBest > 0) { // Avoid division by zero if somehow target is at exact same spot
                        return { dx: dx / distToBest, dy: dy / distToBest }; // Return normalized direction
                     }
                }
            }

            // If no target found, or target is already close enough, no specific healing movement needed.
            return null;
        }

           // Heals the single "best" target ally (NOT self) within healRange
      // Best is determined by a score combining missing health and proximity.
      healNearbyUnits() {
          let bestTarget = null;
          let highestScore = -1; // Use -1 to ensure any valid target is chosen initially

          // Find the best target unit (NOT self) currently within healRange
          for (const unit of units) {
              // Skip self & units at full health
              if (unit === this || unit.hp >= unit.maxHp) continue;

              const dist = this.distanceTo(unit);

              // Check if IN heal range
              if (dist < this.healRange) {
                  // Calculate score: missing health / distance
                  // Add a small amount to distance to prevent division by zero
                  // and slightly de-prioritize targets right on top of the mage.
                  const distanceFactor = Math.max(dist, 1.0); // Avoid division by zero or tiny distances
                  const missingHp = unit.maxHp - unit.hp;
                  const score = missingHp / distanceFactor;

                  // If this unit has a higher score than the best found so far
                  if (score > highestScore) {
                      highestScore = score;
                      bestTarget = unit;
                  }
              }
          }

          // If a valid target was found within range based on score, heal only that target
          if (bestTarget) {
            // --- START MANA CHECK ---
              // Check if we have enough mana *before* attempting to heal
              if (this.currentMana >= this.healManaCost) {
                   const oldHp = bestTarget.hp;
                   bestTarget.hp = Math.min(bestTarget.hp + this.healRate, bestTarget.maxHp);

                   if (bestTarget.hp > oldHp) {
                       // Healing was successful, now subtract mana
                       this.currentMana -= this.healManaCost; // Subtract cost
                       bestTarget.isBeingHealed = true;
                       playSound(sndHealPulse);
                   }
                   // Else: HP was already max, no mana cost, no sound/flag needed
              } else {
                  // Not enough mana to initiate heal tick (optional: play sound?)
                  // playSound(sndNoMana); // Maybe too noisy if played every frame?
              }
              // --- END MANA CHECK ---
	  }
      }

      triggerBounceOff() {
          let enemyInRange = false;
          for (const enemy of enemies) {
              if (enemy.hp <= 0) continue;
              const dist = this.distanceTo(enemy);
              if (dist < this.bounceTriggerRange) {
                  enemyInRange = true;
                  break;
              }
          }
          if (enemyInRange) {
              this.performBounce();
          }
      }

     performBounce() {
	  // --- START MANA CHECK ---
          if (this.currentMana < this.bounceManaCost) {
              //playSound(sndNoMana); // Play "fizzle" or "error" sound
              return; // Not enough mana, do nothing else
          }
          // Sufficient mana, proceed:
          this.currentMana -= this.bounceManaCost; // Subtract cost
          // --- END MANA CHECK ---
          // --- START ADDITION: Trigger Shockwave ---
          this.shockwaveActive = true;
          this.shockwaveTimer = this.shockwaveDuration;
          // --- DETAILED LOGGING ---
          console.log(`%cBOUNCE TRIGGERED: Mage (${this.x.toFixed(0)}, ${this.y.toFixed(0)}): shockwaveActive SET to true, shockwaveTimer SET to ${this.shockwaveTimer}`, "color: blue; font-weight: bold;");
          // --- END DETAILED LOGGING ---

            playSound(sndMageBounce);

            // Visual effect for bounce (Original static green circle - KEEP FOR NOW)
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.bounceEffectRange, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(46, 204, 113, 0.2)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(46, 204, 113, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
            // END Static green circle drawing

            // Apply bounce velocity to enemies
            for (const enemy of enemies) {
               if (enemy.hp <= 0) continue;
               const dist = this.distanceTo(enemy);
               if (dist > 0 && dist < this.bounceEffectRange) {
                   const dx = enemy.x - this.x;
                   const dy = enemy.y - this.y;
                   const normalizedX = dx / dist;
                   const normalizedY = dy / dist;
                   enemy.bounceVelX = normalizedX * this.bounceInitialSpeed;
                   enemy.bounceVelY = normalizedY * this.bounceInitialSpeed;
               }
            }
            this.bounceCooldown = this.bounceCooldownMax; // Reset cooldown

        }

        // Mages don't shoot projectiles in this setup
        shoot(target) { } // This is now correctly placed AFTER performBounce closes
        attack(target) { } // Mages don't melee attack

	 draw() {
          // 1. Call the base Unit's draw method to draw body and HP bar
          super.draw(); // Executes Unit.prototype.draw()

          // 2. Draw the Mana Bar below the HP bar
          const manaRatio = Math.max(0, this.currentMana / this.maxMana);
          const barWidth = this.radius * 2.5; // Same width as HP bar
          const barHeight = 4;
          const barX = this.x - barWidth / 2;
          // Position it below the HP bar (HP bar is at y - radius - 8)
          const barY = this.y - this.radius - 8 + barHeight + 2; // Add HP bar height + 2px gap

          ctx.fillStyle = '#333'; // Background
          ctx.fillRect(barX, barY, barWidth, barHeight);
          ctx.fillStyle = '#3498db'; // Blue color for mana
          ctx.fillRect(barX, barY, barWidth * manaRatio, barHeight);
      }
    } // End of Mage Class

    // --- Projectile Class ---
    class Projectile {
      constructor(x, y, target, damage, owner) { // Added damage and owner
        this.x = x;
        this.y = y;
        this.target = target;
        this.damage = damage;
        this.owner = owner; // The unit that fired the projectile
        this.speed = 5;
        this.radius = 4;
        this.color = 'black';
        this.done = false; // Flag for removal
      }

      update() {
        if (this.target.hp <= 0 || !this.target) {
          this.done = true; // Target died or disappeared
          return;
        }

        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const dist = Math.hypot(dx, dy);

        // Check for hit (collision)
        if (dist < this.target.radius + this.radius || dist < this.speed) {
	  const oldHp = this.target.hp; // Store target's HP *before* dealing damage
          this.target.hp -= this.damage;
          this.done = true;

	  // --- ADD SOUND ---
     // Play hit sound only if damage was dealt
     if(this.target.hp < oldHp) {
        //playSound(sndArrowHit);
     }
     // --- END SOUND ---
          
                // Ensure the owner unit clears its target if its current target just died
                if (this.owner && this.owner.target === this.target) {
                    this.owner.target = null;
                
           }
        } else {
          // Move towards target
          this.x += (dx / dist) * this.speed;
          this.y += (dy / dist) * this.speed;
        }
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    } // End of Projectile Class

	    // --- START UPDATED HIGH SCORE FUNCTIONS (v9 Syntax) ---

    /**
     * Fetches high scores from Firebase, sorted descending by score.
     * @returns {Promise<Array>} A promise that resolves with an array of score objects.
     */
    async function loadHighScoresFromFirebase() {
        console.log("Loading high scores from Firebase (v9)...");
        // Create the query: order by 'score' descending, limit to MAX_HIGH_SCORES
        const q = query(highScoresCollectionRef, orderBy('score', 'desc'), limit(MAX_HIGH_SCORES));
        try {
            const querySnapshot = await getDocs(q); // Execute the query
            const scores = [];
            querySnapshot.forEach((doc) => {
                // doc.data() contains the fields (name, score, timestamp)
                scores.push({ id: doc.id, ...doc.data() });
            });
            console.log("Loaded scores (v9):", scores.length);
            return scores;
        } catch (error) {
            console.error("Error loading high scores (v9):", error);
            return []; // Return empty array on error
        }
    }

    /**
     * Checks if a score qualifies for the high score list.
     * Assumes 'scores' array is sorted descending.
     * @param {number} score The player's score.
     * @param {Array} currentHighScores The currently loaded high scores.
     * @returns {boolean} True if it's a high score, false otherwise.
     */
    function isHighScore(score, currentHighScores) {
        // This function logic doesn't change based on Firebase version
        if (!currentHighScores || currentHighScores.length === 0) return true; // Qualifies if list is empty

        return currentHighScores.length < MAX_HIGH_SCORES || score > currentHighScores[currentHighScores.length - 1].score;
    }

    /**
     * Saves a new high score to Firebase using v9 syntax.
     * @param {string} name Player's name.
     * @param {number} score Player's score.
     * @returns {Promise<boolean>} A promise that resolves with true on success, false on error.
     */
    async function saveHighScoreToFirebase(name, score) {
        console.log(`Attempting to save score (v9): ${name} - ${score}`);
        // Basic validation (same as before)
        if (!name || typeof name !== 'string' || name.trim().length === 0 || name.length > 49) {
             console.error("Invalid name provided for high score.");
             alert("Please enter a valid name (1-49 characters).");
             return false;
        }
        if (typeof score !== 'number' || score <= 0) {
             console.error("Invalid score provided for high score.");
             return false;
        }

        try {
            // Use addDoc with the collection reference and data object
            const docRef = await addDoc(highScoresCollectionRef, {
                name: name.trim(),
                score: score,
                timestamp: serverTimestamp() // Use the imported serverTimestamp function
            });
            console.log("High score saved successfully with ID: ", docRef.id);
            return true;
        } catch (error) {
            console.error("Error saving high score (v9):", error);
            alert("Could not save high score. Please try again.");
            return false;
        }
    }

    /**
     * Displays the high scores in an HTML element. (No changes needed)
     * @param {Array} scores Array of score objects.
     * @param {string} containerId The ID of the HTML element to display scores in.
     */
    function displayHighScores(scores, containerId) {
        // This function logic remains exactly the same
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '<h3>High Scores:</h3>';
        if (!scores || scores.length === 0) {
            container.innerHTML += '<p>No scores yet!</p>';
            return;
        }

        const list = document.createElement('ol');
        scores.forEach((scoreData, index) => {
            const item = document.createElement('li');
            const nameText = scoreData.name ? scoreData.name.replace(/</g, "<").replace(/>/g, ">") : "???";
            const scoreNum = typeof scoreData.score === 'number' ? scoreData.score : 0;
            // Display timestamp nicely (optional)
            let dateString = '';
            if (scoreData.timestamp && scoreData.timestamp.toDate) { // Check if it's a Firebase timestamp
                 dateString = ` - ${scoreData.timestamp.toDate().toLocaleDateString()}`;
            }
            item.textContent = `${nameText} - ${scoreNum}${dateString}`; // Added optional date
            list.appendChild(item);
        });
        container.appendChild(list);
    }

    // --- END UPDATED HIGH SCORE FUNCTIONS ---
	  
    // --- Game Functions ---

    function spawnUnit(type) {
      if (!gameRunning) return;
       // Only check cap for player units (not 'enemy')
      if (type !== 'enemy') {
          if (units.length >= currentArmyCap) {
              console.log(`Army cap reached (${currentArmyCap}). Cannot spawn ${type}.`);
              // Optional: Add visual feedback - flash the cap button red?
              flashElement(document.getElementById('upgradeCapButton'), 'lightcoral');
              return; // Stop spawning if cap is reached
          }
      }
      const costs = { melee: 10, archer: 15, mage: 50 };
      const cost = costs[type] || 0; // Default cost 0 if type not found

      if (type !== 'enemy') { // Player unit spawn
          if (score < cost) {
	      playSound(sndNoGold);
              console.log(`Not enough gold to spawn ${type}. Need ${cost}, have ${score}`);
               flashElement(getSpawnButtonByType(type), 'lightcoral'); // Helper needed
              return;
          }
          score -= cost;
          updateScoreDisplay();
	  playSound(sndSpawnSuccess); // Play sound on successful spawn
      }

      // Spawn player units near the castle, enemies near the top
      let spawnX, spawnY;
      if (type === 'enemy') {
          spawnX = Math.random() * (canvas.width - SAFE_MARGIN * 2) + SAFE_MARGIN;
          spawnY = SAFE_MARGIN + Math.random() * 50; // Spawn near top edge
      } else {
          // Spawn player units in a zone in front of the castle
          const spawnZoneY = castle.y - castle.height / 2 - 60;
          spawnX = castle.x + (Math.random() - 0.5) * castle.width * 1.5;
          spawnY = spawnZoneY + (Math.random() - 0.5) * 40;
          // Clamp spawn position to be within canvas bounds
          spawnX = Math.max(SAFE_MARGIN, Math.min(spawnX, canvas.width - SAFE_MARGIN));
          spawnY = Math.max(SAFE_MARGIN, Math.min(spawnY, canvas.height - SAFE_MARGIN - castle.height)); // Prevent spawning inside castle visually
      }


      let newUnit;
      if (type === 'mage') {
          newUnit = new Mage(spawnX, spawnY);
      } else { // Melee, Archer, or Enemy
          newUnit = new Unit(spawnX, spawnY, type);
      }

      if (type === 'enemy') {
          enemies.push(newUnit);
	  playSound(sndEnemySpawn);
      } else {
          units.push(newUnit);
      }
    }


	 function getSpawnButtonByType(type) {
        const buttons = document.querySelectorAll('#controls button');
        if (type === 'melee') return buttons[0];
        if (type === 'archer') return buttons[1];
        if (type === 'mage') return buttons[2];
        return null;
    }

    // General purpose element flasher
    function flashElement(element, flashColor = 'lightcoral', originalColor = null, duration = 200) {
       if (element) {
            const originalBg = originalColor !== null ? originalColor : element.style.backgroundColor;
            element.style.transition = 'background-color 0.1s ease-in-out'; // Ensure transition is set
            element.style.backgroundColor = flashColor;
            setTimeout(() => {
                 // Check element still exists before reverting
                 if(document.body.contains(element)) {
                     element.style.backgroundColor = originalBg;
                 }
            }, duration);
        }
    }
    
     function calculateNextCapUpgradeCost() {
        // Cost increases exponentially based on the number of upgrades already purchased
        const cost = BASE_ARMY_CAP_UPGRADE_COST * Math.pow(ARMY_CAP_UPGRADE_COST_SCALING, armyCapUpgradeLevel);
        return Math.floor(cost); // Use floor to keep costs as integers
    }

    function updateUpgradeButtonDisplay() {
        const button = document.getElementById('upgradeCapButton');
        if (!button) return;

        const nextCost = calculateNextCapUpgradeCost();
        const nextCap = currentArmyCap + ARMY_CAP_INCREASE_PER_UPGRADE;

        button.innerHTML = `[U]pgrade Cap (${currentArmyCap} -> ${nextCap}) (Cost: ${nextCost}ðŸª™)`;
    }

    function upgradeArmyCap() {
        if (!gameRunning) return;

        const cost = calculateNextCapUpgradeCost();

        if (score >= cost) {
            // Affordable: Perform upgrade
            score -= cost;
            currentArmyCap += ARMY_CAP_INCREASE_PER_UPGRADE;
            armyCapUpgradeLevel++; // Increment the level tracker

            console.log(`Army cap upgraded to ${currentArmyCap}. Level: ${armyCapUpgradeLevel}`);

            updateScoreDisplay(); // Update score shown
            updateUpgradeButtonDisplay(); // Update button text for the *next* upgrade

            // Optional: Flash button green on success
             flashElement(document.getElementById('upgradeCapButton'), 'lightgreen', '#d4af37'); // Flash green, revert to gold

        } else {
            // Unaffordable
            console.log(`Not enough gold to upgrade army cap. Need ${cost}, have ${score}`);
            // Optional: Flash button red on failure
            flashElement(document.getElementById('upgradeCapButton'), 'lightcoral', '#d4af37'); // Flash red, revert to gold
        }
    }
    
     function updateWaveStatusDisplay(message) {
        const statusElement = document.getElementById('waveStatus');
        if (statusElement) {
            statusElement.innerText = message;
        }
    }

    function startNextWave() {
        currentWave++;
        waveState = 'SPAWNING';
	playSound(sndWaveStart);

        // Calculate wave parameters
        enemiesToSpawnThisWave = BASE_ENEMY_COUNT + (currentWave - 1) * ENEMY_COUNT_INCREASE_PER_WAVE;
        waveSpawnInterval = Math.max(MIN_SPAWN_INTERVAL, BASE_SPAWN_INTERVAL - (currentWave - 1) * SPAWN_INTERVAL_DECREASE_PER_WAVE);

        enemiesSpawnedThisWave = 0;
        spawnTimer = waveSpawnInterval; // Start ready to spawn first enemy relatively quickly

        console.log(`Starting Wave ${currentWave}: ${enemiesToSpawnThisWave} enemies, spawn interval ${waveSpawnInterval} frames.`);
        updateWaveStatusDisplay(`Wave ${currentWave} Starting!`);

        // No explicit wave duration timer; wave ends when all enemies are spawned.
        waveTimer = 0; // Reset or repurpose waveTimer if needed later
    }

    function updateWaveLogic() {
        if (!gameRunning) return;

        if (waveState === 'INTERMISSION') {
            waveTimer--; // Countdown intermission timer

            // Display remaining time (optional, convert frames to seconds)
            const secondsLeft = Math.ceil(waveTimer / 60);
            updateWaveStatusDisplay(`Wave ${currentWave} Complete! Next wave in ${secondsLeft}s...`);

            if (waveTimer <= 0) {
                startNextWave();
            }
        } else if (waveState === 'SPAWNING') {
            spawnTimer--; // Countdown timer for next spawn

            if (spawnTimer <= 0 && enemiesSpawnedThisWave < enemiesToSpawnThisWave) {
                spawnUnit('enemy'); // Spawn one enemy
                enemiesSpawnedThisWave++;
                spawnTimer = waveSpawnInterval; // Reset timer for the next spawn

                // Update display (optional)
                updateWaveStatusDisplay(`Wave ${currentWave} | Spawning: ${enemiesSpawnedThisWave} / ${enemiesToSpawnThisWave}`);
            }

            // Check if all enemies for this wave have been spawned
            if (enemiesSpawnedThisWave >= enemiesToSpawnThisWave) {
            	  // Award bonus immediately after last enemy spawns for Wave 1 onwards
            if (currentWave > 0) {
                // Calculate the reward
                const waveReward = WAVE_CLEAR_BASE_GOLD + (currentWave * WAVE_CLEAR_GOLD_PER_WAVE);

                // Add reward to score/gold
                score += waveReward;
                mathScore += WAVE_CLEAR_GOLD_PER_WAVE*2; // Assuming you want to add to both

                // Log feedback to console
                console.log(`Wave ${currentWave} spawning complete! Bonus: +${waveReward} Gold/Score`);

                // Update the score display on the screen
                updateScoreDisplay();

                // Optional: Add a brief visual flash to the score display
                const scoreElement = document.getElementById('scoreDisplay');
                if (scoreElement) {
                    scoreElement.style.transition = 'background-color 0.1s ease-in-out';
                    scoreElement.style.backgroundColor = 'lightgoldenrodyellow';
                    setTimeout(() => {
                        scoreElement.style.backgroundColor = ''; // Revert color
                    }, 200); // Flash duration
                }
            }
                waveState = 'INTERMISSION';
                waveTimer = BASE_INTERMISSION_DURATION; // Start the standard intermission countdown
                console.log(`Wave ${currentWave} spawning complete. Starting intermission.`);
                // Update display immediately for intermission start
                 updateWaveStatusDisplay(`Wave ${currentWave} Complete! Prepare for Wave ${currentWave + 1}...`);
            }
        }
    }

	  function handleKeyPress(event) {
    // Ignore key presses if the game isn't running
    if (!gameRunning) return;

    const key = event.key;
    const lowerKey = key.toLowerCase(); // Use lowercase for checking m, a, g
    const answerInput = document.getElementById('answerInput');
    const isInputFocused = document.activeElement === answerInput;

    // Define keys that are ESSENTIAL for the number input field
    const essentialInputKeys = [
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '-', // Minus sign
        'Backspace', 'Delete',
        'ArrowLeft', 'ArrowRight',
        'Enter', // Allows submitting the form via Enter key
        'Tab'    // Allows standard navigation
        // Add 'Home', 'End' if needed
    ];

    // If the input field is focused AND the key is essential for typing, allow it
    if (isInputFocused && essentialInputKeys.includes(key)) {
        return; // Allow default behavior (typing number, deleting, etc.)
    }

    // Handle the game shortcuts (M, A, G)
    let shortcutUsed = false;
    switch (lowerKey) {
        case 'm': // M key for Melee
            spawnUnit('melee');
            flashButton('melee');
            shortcutUsed = true;
            break;
        case 'a': // A key for Archer
            spawnUnit('archer');
            flashButton('archer');
            shortcutUsed = true;
            break;
        case 'g': // G key for Mage
            spawnUnit('mage');
            flashButton('mage');
            shortcutUsed = true;
            break;
        case 'u': // U key for Upgrade Cap
            upgradeArmyCap(); // Call the upgrade function
            shortcutUsed = true;
            break;
    }

    // If a shortcut key (M, A, G) was just processed, prevent its default action.
    // This should reliably stop 'm', 'a', or 'g' from appearing in the input box
    // if it happened to have focus when the key was pressed.
    if (shortcutUsed) {
        event.preventDefault();
    }
}

 function flashButton(unitType) {
        const buttons = document.querySelectorAll('#controls button');
        let targetButton = null;
        if (unitType === 'melee') targetButton = buttons[0];
        else if (unitType === 'archer') targetButton = buttons[1];
        else if (unitType === 'mage') targetButton = buttons[2];

        if (targetButton) {
            const originalColor = targetButton.style.backgroundColor;
            targetButton.style.backgroundColor = 'lightgreen'; // Highlight color
            setTimeout(() => {
                targetButton.style.backgroundColor = originalColor; // Revert color
            }, 150); // Highlight duration (150ms)
        }
    }
	  
    async function gameOver() {
	console.error("!!! GAMEOVER FUNCTION ENTERED !!!"); // Add this line
        if (!gameRunning) return; // Prevent multiple calls
        console.log("GAME OVER");
        gameRunning = false; // Stop game logic
	playSound(sndGameOver);

        // Display game over screen
        const gameOverScreen = document.getElementById('gameOverScreen');
        gameOverScreen.style.display = 'flex'; // Use flex for centering
        gameOverScreen.style.flexDirection = 'column';
        gameOverScreen.style.justifyContent = 'center';
        gameOverScreen.style.alignItems = 'center';

	     // --- START HIGH SCORE INTEGRATION ---
    gameOverScreen.innerHTML = '<h2>Game Over!</h2>'; // Clear previous content

    const finalScoreDisplay = document.createElement('p');
    finalScoreDisplay.style.fontSize = '24px';
    finalScoreDisplay.textContent = `Final Score: ${mathScore}`;
    gameOverScreen.appendChild(finalScoreDisplay);

    const highScoreContainer = document.createElement('div');
    highScoreContainer.id = 'highScoreListContainer'; // ID for display function
    highScoreContainer.style.marginTop = '20px';
    highScoreContainer.style.textAlign = 'left';
    highScoreContainer.innerHTML = '<p>Loading high scores...</p>'; // Placeholder
    gameOverScreen.appendChild(highScoreContainer);

    // Load existing scores
    const currentHighScores = await loadHighScoresFromFirebase();

    // Check if the current score is a high score
    if (isHighScore(mathScore, currentHighScores)) {
        console.log("New High Score!");
        finalScoreDisplay.textContent += " - New High Score!";

        // Create input form
        const form = document.createElement('div'); // Use div instead of form to prevent reload
        form.style.marginTop = '15px';
        form.innerHTML = `
            <label for="playerNameInput">Enter Name:</label>
            <input type="text" id="playerNameInput" maxlength="49" required>
            <button id="submitScoreBtn">Save Score</button>
        `;
        // Insert form before the high score list container
        gameOverScreen.insertBefore(form, highScoreContainer);

        const nameInput = document.getElementById('playerNameInput');
        const submitBtn = document.getElementById('submitScoreBtn');

         // Add focus to input shortly after display
         setTimeout(() => nameInput.focus(), 100);


        submitBtn.onclick = async () => { // Use async for saving
            const playerName = nameInput.value;
            if (playerName && playerName.trim().length > 0) {
                submitBtn.disabled = true; // Prevent double submit
                submitBtn.textContent = 'Saving...';
                const saved = await saveHighScoreToFirebase(playerName, mathScore);
                if (saved) {
                    // Remove form, refresh list
                    form.remove();
                    const updatedScores = await loadHighScoresFromFirebase();
                    displayHighScores(updatedScores, highScoreContainer.id);
                } else {
                    // Re-enable button on failure
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Save Score';
                    // Error message already shown by save function via alert
                }
            } else {
                 alert("Please enter a name.");
            }
        };

         // Also allow Enter key in input field to submit
         nameInput.onkeydown = (event) => {
            if (event.key === 'Enter') {
                submitBtn.click(); // Trigger button click
                event.preventDefault(); // Prevent default form submission
            }
         };

        // Display current scores below the input form
        displayHighScores(currentHighScores, highScoreContainer.id);

    } else {
         // Not a high score, just display the list
         console.log("Score not high enough for leaderboard.");
         displayHighScores(currentHighScores, highScoreContainer.id);
    }

     // Optional: Add a button or click handler to restart
     const restartButton = document.createElement('button');
     restartButton.textContent = 'Play Again?';
     restartButton.style.marginTop = '30px';
     restartButton.style.padding = '10px 20px';
     restartButton.onclick = () => { location.reload(); }; // Simple reload
     gameOverScreen.appendChild(restartButton);


    // --- END HIGH SCORE INTEGRATION ---

    }


    function gameLoop() {
      if (!gameRunning) return; // Exit loop if game is over

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background elements
      drawCastle();
		 updateWaveLogic(); // Handle wave progression and enemy spawning
         updateArmyCountDisplay(); // Update the display every frame
      // Update and Draw Units (player and enemy)
      [...units, ...enemies].forEach(u => {
        if (u.update) u.update(); // Make sure update exists before calling
        if (u.draw) u.draw();   // Make sure draw exists
      });
	    

      // Update and Draw Projectiles
      projectiles.forEach((p, index) => {
        if (p.update) p.update();
        if (p.draw) p.draw();
      });

      // Remove 'done' projectiles
      for (let i = projectiles.length - 1; i >= 0; i--) {
        if (projectiles[i].done) {
          projectiles.splice(i, 1);
        }
      }
	         // --- Draw Active Shockwaves (Orange/Red) ---
      // Drawing AFTER units ensures the effect isn't immediately covered
      ctx.save();
      units.forEach(unit => {
          // Check if it's a Mage AND its shockwave is active
          if (unit instanceof Mage && unit.shockwaveActive) {

              // --- START REPLACEMENT: Restore Dynamic Circle ---
              // Calculate animation progress (0 = start, 1 = end)
              const progress = 1.0 - (unit.shockwaveTimer / unit.shockwaveDuration);

              // Calculate current radius based on progress (linear expansion)
              const currentRadius = unit.shockwaveMaxRadius * progress;

              // Calculate opacity (fades out from 1 to 0)
              const opacity = 1.0 - progress;

              // Set drawing style (e.g., Orange/Red fading out)
              // Ensure opacity is not negative if timer logic is slightly off
              const safeOpacity = Math.max(0, opacity);
              ctx.strokeStyle = `rgba(255, 100, 0, ${safeOpacity})`; // Orange-Red, fades alpha

              // Make line thinner as it expands (optional)
              const currentLineWidth = Math.max(1, 4 * (1.0 - progress) + 1);
              ctx.lineWidth = currentLineWidth;

              // Draw the expanding circle
              ctx.beginPath();
              ctx.arc(unit.x, unit.y, currentRadius, 0, Math.PI * 2);
              // Only stroke if opacity is still significant to avoid drawing invisible lines
              if (safeOpacity > 0.05) {
                   ctx.stroke();
              }
              // --- END REPLACEMENT ---

              // Optional: Keep this log temporarily if you want to verify parameters
              // console.log(`DEBUG: Drawing shockwave indicator for Mage at (${unit.x.toFixed(0)}, ${unit.y.toFixed(0)}), Timer: ${unit.shockwaveTimer}`);
          }
      });
      ctx.restore();
      // --- End Draw Active Shockwaves ---

	 // --- START ADDITION: Draw Mana Charge Pulse ---
        ctx.save();
        units.forEach(unit => {
            // Draw ONLY if it's a Mage AND it's currently in the 'waiting for mana' state
            if (unit instanceof Mage && unit.isFleeingOOM) {
                // Calculate pulsing effect using sine wave based on the cycling timer
                // progress goes 0 -> 1 over the duration
                const progress = unit.manaChargeAnimTimer / unit.manaChargeAnimDuration;
                // angle goes 0 -> 2*PI
                const angle = progress * Math.PI * 2;
                // pulseFactor goes 0 -> 1 -> 0 using sine shifted -PI/2
                const pulseFactor = (Math.sin(angle - Math.PI / 2) + 1) / 2;

                // Calculate current radius based on pulse (e.g., radius * 0.5 up to maxRadius)
                const currentRadius = (unit.radius * 0.5) + (unit.manaChargeMaxRadius - unit.radius * 0.5) * pulseFactor;

                // Calculate current opacity based on pulse
                const currentOpacity = unit.manaChargeBaseOpacity * pulseFactor;

                // Set drawing style (Blue, pulsing opacity)
                ctx.fillStyle = `rgba(52, 152, 219, ${currentOpacity})`; // Blue color (adjust RGB as desired)

                // Draw the pulsing circle (filled, no stroke)
                ctx.beginPath();
                ctx.arc(unit.x, unit.y, currentRadius, 0, Math.PI * 2);
                // Only draw if slightly visible
                if (currentOpacity > 0.05 && currentRadius > 1) {
                    ctx.fill();
                }
            }
        });
        ctx.restore();
        // --- END ADDITION ---
	    
       // Check for castle destruction (redundant check, but safe)
       if (castle.hp <= 0) {
           gameOver();
       }

      // Request next frame
      requestAnimationFrame(gameLoop);
    } 
    updateScoreDisplay();
    askMathProblem();
     currentWave = 0; // Start before Wave 1
    waveState = 'INTERMISSION';
    waveTimer = INITIAL_INTERMISSION_DURATION; // Set initial pause before Wave 1 starts
    updateWaveStatusDisplay(`Get Ready! Wave 1 starting soon...`);
    gameLoop(); // Start the main game loop
    
    window.addEventListener('keydown', handleKeyPress);
    const answerInput = document.getElementById('answerInput'); // Get reference once if possible outside loop

if (answerInput) { // Make sure the element exists before adding listener
  answerInput.addEventListener('input', function(event) {
    // Get the current value
    const value = event.target.value;

    // Remove any 'e' or 'E' characters using regex (global, case-insensitive)
    // Also remove '+' as some browsers allow it in number fields
    const sanitizedValue = value.replace(/[eE+]/g, '');

    // If the sanitized value is different from the original value, update the input
    if (sanitizedValue !== value) {
        event.target.value = sanitizedValue;
    }
  });
} else {
    console.error("Could not find answerInput to attach input listener!");
}

updateUpgradeButtonDisplay();
updateArmyCountDisplay(); // Set initial army count display

  </script>
</body>
</html>
